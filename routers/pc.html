<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>WeChat Mock</title>

<style>
*{
    box-sizing:border-box;
}

html,body{
    margin:0;
    height:100%;
    background:#ededed;
    font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Microsoft YaHei",sans-serif;
    overflow:hidden;
}

.app{
    width:100%;
    height:100%;
    background:#fff;
    display:flex;
    flex-direction:column;
}

/* é¡¶éƒ¨ */
.header{
    height:64px;
    background:#f7f7f7;
    border-bottom:1px solid #e5e5e5;
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:0 40px;
    font-size:18px;
    font-weight:600;
}

/* èŠå¤©åŒºåŸŸ */
.chat{
    flex:1;
    background:#f5f5f5;
    padding-bottom:20px
    padding:40px;
    overflow-y:auto;
}

.msg{
    display:flex;
    margin-bottom:22px;
}

.msg.right{
    justify-content:flex-end;
}

.bubble{
    max-width:60%;
    padding:12px 18px;
    font-size:14px;
    line-height:1.6;
    border-radius:6px;
    word-break:break-word;
}

.left .bubble{
    background:#ffffff;
}

.right .bubble{
    background:#95ec69;
}

/* ===== è¾“å…¥åŒº ===== */

.input-wrapper{
    background:#f5f5f5;
    border-top:1px solid #e5e5e5;
    padding:8px 20px 15px 20px;
    display:flex;
    flex-direction:column;
    justify-content:flex-start;
    position:relative;
}

/* å·¥å…·æ  */
.tool-row{
    display:flex;
    gap:11px;
    font-size:22px;
    color:#666;
    margin-bottom:2px;
}

/* ç¼–è¾‘åŒºåŸŸ */
.editor-row{
    position:relative;
    display:flex;
    align-items:flex-end;
}

textarea{
    flex:1;
    height:100px;
    border:none;
    resize:none;
    outline:none;
    font-size:15px;
    line-height:1.6;
    padding:5px 0;
    background:transparent;
}

textarea:focus{
    caret-color:#07c160;
}

/* å‘é€æŒ‰é’® */
.send{
    position:absolute;
    right:0;
    bottom:20;
    padding:8px 28px;
    border:none;
    border-radius:4px;
    font-size:14px;
    background:#e5e5e5;
    color:#999;
    cursor:not-allowed;
    transition:0.2s;
}

.send.active{
    background:#07c160;
    color:#fff;
    cursor:pointer;
}

.chat::-webkit-scrollbar{
    width:6px;
}
.chat::-webkit-scrollbar-thumb{
    background:#ccc;
    border-radius:3px;
}
    .msg{
    display:flex;
    align-items:flex-start;
    margin-bottom:22px;
}

.msg.right{
    justify-content:flex-end;
}

.avatar{
    width:36px;
    height:36px;
    border-radius:4px;
    background:#ccc;
    margin:0 10px;
}

.left .bubble{
    background:#ffffff;
    margin-left:0;
}

.right .bubble{
    background:#95ec69;
    margin-right:0;
}
    .chat{
    padding:40px 40px 40px 40px;
}

.chat .msg:first-child{
    margin-top:32px;
}
/* ===== å³ä¸Šè§’èœå•æŒ‰é’® ===== */
.menu-btn{
    font-size:22px;
    cursor:pointer;
    padding:0 10px;
}

/* ===== é®ç½©å±‚ ===== */
/* æ‰“å¼€çŠ¶æ€ */
.overlay{
    position:absolute;
    top:64px;
    left:0;
    width:100%;
    height:calc(100% - 64px);
    background:rgba(0,0,0,0.15);

    opacity:0;
    pointer-events:none;

    transition:opacity 0.3s ease;
    z-index:9;
}

.overlay.show{
    opacity:1;
    pointer-events:auto;
}
/* ===== æŠ½å±‰ ===== */
.drawer{
    position:absolute;
    top:0;
    right:0;
    width:40%;
    height:100%;
    background:#ffffff;
    border-left:1px solid #e5e5e5;
    transform:translateX(100%);
    transition:transform 0.3s ease;
    box-shadow:-4px 0 20px rgba(0,0,0,0.1);
}

/* æ‰“å¼€ */
.overlay.show .drawer{
    transform:translateX(0);
}
    .drawer-content{
    padding:20px;
    overflow-y:auto;
    height:100%;
    background:#f5f5f5;
}

/* å¡ç‰‡ */
.card{
    background:#ffffff;
    border-radius:16px;
    padding:20px;
    margin-bottom:20px;
    box-shadow:0 2px 10px rgba(0,0,0,0.05);
}

/* å¤´åƒ */
.avatar-large{
    width:60px;
    height:60px;
    border-radius:50%;
    background:#d8dde6;
}

.profile-top{
    display:flex;
    gap:15px;
    align-items:center;
}

.username{
    font-size:18px;
    font-weight:600;
    color:#4b6ea9;
}

.desc{
    font-size:13px;
    color:#c44;
}

.divider{
    height:1px;
    background:#e6e6e6;
    margin:15px 0;
}

/* å¼€å…³ */
.toggle-row{
    display:flex;
    justify-content:space-between;
    align-items:center;
}

.switch{
    width:46px;
    height:26px;
    background:#e5e5e5;
    border-radius:26px;
    position:relative;
    cursor:pointer;
    transition:background 0.25s ease;
}

.switch::after{
    content:"";
    position:absolute;
    width:22px;
    height:22px;
    left:0px;
    top:0px;
    background:#fff;
    border-radius:50%;
    transition:transform 0.25s ease;
    box-shadow:0 1px 3px rgba(0,0,0,0.15);
}

.switch.on{
    background:#6b8cff;
}

.switch.on::after{
    transform:translateX(20px);
}

.modal-card {
    background:#ffffff;
    border-radius:20px;
    padding:28px;
    box-shadow:0 25px 60px rgba(0,0,0,0.12);
    animation:fadeInScale .2s ease;
}

@keyframes fadeInScale {
    from{
        opacity:0;
        transform:scale(.96);
    }
    to{
        opacity:1;
        transform:scale(1);
    }
}

#voice-clone-modal .modal-title{
    font-size:20px;
    font-weight:600;
    color:#2c2c2c;
    margin-bottom:20px;
}

#voice-clone-modal .modal-divider{
    height:1px;
    background:#f1f3f5;
    margin:16px 0;
}

#voice-clone-modal .modal-form{
    display:flex;
    flex-direction:column;
    gap:12px;
}

#voice-clone-modal .modal-label{
    font-size:13px;
    font-weight:500;
    color:#8c8c8c;
}

#voice-clone-modal .input-soft,
#voice-clone-modal textarea.input-soft,
#voice-clone-modal input[type="text"].input-soft,
#voice-clone-modal input[type="file"].input-soft {
    width:100%;
    border:none;
    background:#f7f8fa;
    padding:14px 16px;
    border-radius:14px;
    font-size:14px;
    color:#2c2c2c;
    box-sizing:border-box;
    transition:.2s;
}

#voice-clone-modal .input-soft::placeholder{
    color:#a0a0a0;
}

#voice-clone-modal .input-soft:focus{
    outline:none;
    background:#ffffff;
    box-shadow:0 0 0 3px rgba(124,131,253,.15);
}

#voice-clone-modal input[type="file"].input-soft{
    border:none;
    background:#f1f3f5;
    border-radius:12px;
    padding:10px 14px;
    cursor:pointer;
}

#voice-clone-modal input[type="file"].input-soft:hover{
    background:#e9ecef;
}

#voice-clone-modal input[type="file"].input-soft::file-selector-button{
    border:none;
    background:#ffffff;
    color:#555;
    border-radius:10px;
    padding:8px 12px;
    margin-right:10px;
    cursor:pointer;
}

.voice-emotion-card {
    background:#fafafa;
    border-radius:18px;
    padding:18px;
    margin:8px 0;
}

.voice-emotion-header {
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:12px;
}

.voice-emotion-title{
    font-size:15px;
    color:#2c2c2c;
    font-weight:600;
}

.voice-emotion-reset{
    border:none;
    background:#f1f3f5;
    color:#666;
    border-radius:12px;
    padding:8px 12px;
    cursor:pointer;
}

.voice-emotion-sliders {
    display:flex;
    flex-direction:column;
}

.voice-emotion-item{
    display:flex;
    align-items:center;
    margin-bottom:14px;
    gap:10px;
}

.voice-emotion-item:last-child{
    margin-bottom:0;
}

.voice-emotion-item > span:first-child{
    width:60px;
    font-size:14px;
    color:#555;
}

.voice-emotion-value{
    width:24px;
    text-align:right;
    color:#7c83fd;
    font-weight:500;
}

#voice-clone-modal input[type="range"]{
    -webkit-appearance:none;
    appearance:none;
    width:100%;
    height:6px;
    border-radius:6px;
    background:#e9ecef;
    outline:none;
    transition:.2s;
    margin:0;
}

#voice-clone-modal input[type="range"]:hover{
    background:#dee2e6;
}

#voice-clone-modal input[type="range"]::-webkit-slider-runnable-track{
    height:6px;
    border-radius:6px;
    background:transparent;
}

#voice-clone-modal input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance:none;
    height:18px;
    width:18px;
    border-radius:50%;
    background:#7c83fd;
    box-shadow:0 4px 10px rgba(124,131,253,.4);
    cursor:pointer;
    margin-top:-6px;
}

#voice-clone-modal input[type="range"]::-moz-range-track{
    height:6px;
    border-radius:6px;
    background:#e9ecef;
}

#voice-clone-modal input[type="range"]::-moz-range-thumb{
    height:18px;
    width:18px;
    border:none;
    border-radius:50%;
    background:#7c83fd;
    box-shadow:0 4px 10px rgba(124,131,253,.4);
    cursor:pointer;
}

#voice-clone-modal .primary-btn,
#voice-clone-modal .secondary-btn{
    width:100%;
    border:none;
    margin-top:14px;
    cursor:pointer;
}

#voice-clone-modal .primary-btn{
    height:50px;
    border-radius:16px;
    font-size:15px;
    font-weight:600;
    color:#fff;
    background:linear-gradient(135deg,#7c83fd,#6366f1);
    transition:.2s;
}

#voice-clone-modal .primary-btn:hover{
    transform:translateY(-1px);
    box-shadow:0 10px 20px rgba(124,131,253,.3);
}

#voice-clone-modal .secondary-btn{
    height:46px;
    border-radius:14px;
    font-size:14px;
    background:#f1f3f5;
    color:#444;
}

#voice-clone-modal #voice-clone-status{
    color:#8c8c8c;
    font-size:13px;
    min-height:18px;
}

.toast {
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.75);
    color: #fff;
    padding: 10px 18px;
    border-radius: 20px;
    font-size: 13px;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
    z-index: 9999;
}
.toast.show { opacity: 1; }

/* æ ‡é¢˜ */
.section-title{
    font-size:18px;
    font-weight:600;
    color:#4b7bd6;
    margin-bottom:15px;
}

/* åˆ†æ•° */
.score-row{
    display:flex;
    justify-content:space-between;
    margin-bottom:10px;
}

/* è¿›åº¦æ¡ */
.progress{
    height:10px;
    background:#e3e6ef;
    border-radius:10px;
    overflow:hidden;
    margin-bottom:15px;
}

.progress-bar{
    width:60%;
    height:100%;
    background:linear-gradient(to right,#e88,#4b7bd6);
}

/* æ ‡ç­¾ */
.tag-row{
    display:flex;
    gap:10px;
    margin-bottom:15px;
}

.tag{
    background:#dbe6f7;
    color:#4b7bd6;
    padding:6px 14px;
    border-radius:20px;
    font-size:13px;
}

/* åˆ†ææ–‡æœ¬ */
.sub-title{
    font-weight:600;
    color:#4b7bd6;
    margin-top:10px;
}

.analysis p{
    font-size:14px;
    line-height:1.6;
    color:#333;
}

/* è¯­éŸ³æŒ‰é’® */
.voice-btn{
    width:100%;
    padding:12px;
    background:#5f83c6;
    border:none;
    border-radius:30px;
    color:#fff;
    font-size:16px;
    cursor:pointer;
}

.todo{
    font-size:13px;
    color:#777;
    margin-bottom:15px;
}
</style>
</head>

<body>

<div class="app">

    <div class="header">
        å•èŠæ¨¡å¼
        <div class="menu-btn" id="menuBtn">â‹¯</div>
    </div>
    <div class="overlay" id="overlay">
        <div class="drawer" id="drawer">
            <div class="drawer-content">

    <!-- ä¸ªäººä¿¡æ¯å¡ -->
    <div class="card profile-card">
        <div class="profile-top">
            <div class="avatar-large"></div>
                <div class="profile-info">
                    <div class="username">f298d8</div>
                    <div class="desc">èµ„æ–™ä¿®æ”¹è¯·å‰å¾€ç‰ˆæœ¬ä»‹ç»é¡µé¢çš„èœå•</div>
                </div>
            </div>

            <div class="divider"></div>

            <div class="toggle-row">
                <span>è¯­éŸ³è¾“å‡º</span>
                <button class="switch" id="voice-output-toggle" type="button" role="switch" aria-checked="false"></button>
            </div>
        </div>

        <!-- æƒ…ç»ªåˆ†æ -->
        <div class="card">
            <div class="section-title">ğŸ“Š æƒ…ç»ªåˆ†ææŠ¥å‘Š</div>

            <div class="score-row">
                <span>æƒ…ç»ªæŒ‡æ•°</span>
                <span>60 / 100</span>
            </div>

            <div class="progress">
                <div class="progress-bar"></div>
            </div>

            <div class="tag-row">
                <span class="tag">å¹³é™</span>
                <span class="tag">æœŸå¾…</span>
            </div>

            <div class="analysis">
                <div class="sub-title">æƒ…ç»ªåˆ†æï¼š</div>
                <p>å½“å‰æœªæ£€æµ‹åˆ°æ˜æ˜¾çš„è´Ÿé¢æƒ…ç»ªï¼Œå¿ƒæ€å¤„äºå¹³å’Œçš„çŠ¶æ€ï¼Œå¯¹äº¤æµæŠ±æœ‰è½»å¾®æœŸå¾…ã€‚</p>

                <div class="sub-title">æš–å¿ƒå»ºè®®ï¼š</div>
                <p>ä¿æŒè¿™ä»½å¹³å’Œçš„å¿ƒæƒ…ï¼Œå¤§èƒ†è¯´å‡ºä½ çš„æƒ³æ³•å§ï¼Œæˆ‘ä¼šä¸€ç›´åœ¨è¿™é‡Œé™ªç€ä½ ï½</p>
            </div>
        </div>

        <!-- è¯­éŸ³å…‹éš† -->
        <div class="card">
            <div class="section-title">ğŸ™ è¯­éŸ³å…‹éš†</div>
            <p class="todo">TODOï¼šç§»åŠ¨ç«¯å…¥å£ä¿ç•™æ­¤æŒ‰é’®ï¼Œæ¡Œé¢ç«¯è¯·ä½¿ç”¨åº•éƒ¨è¾“å…¥åŒºçš„å¿«æ·å…¥å£ã€‚</p>
            <button class="voice-btn" data-voice-clone-trigger>è¯­éŸ³å…‹éš†</button>
        </div>

    </div>
        </div>
    </div>
    <div class="chat" id="chat"></div>

    <div class="input-wrapper">

        <div class="tool-row">
            <span>ğŸ˜Š</span>
            <span>ğŸ“¦</span>
            <span>ğŸ“</span>
            <span>âœ‚ï¸</span>
            <span>âŒ„</span>
            <span>ğŸ¤</span>
        </div>

        <div class="editor-row">
            <textarea id="input"></textarea>
            <button class="send" id="sendBtn" disabled>å‘é€(S)</button>
        </div>

    </div>

</div>


<div id="voice-clone-modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.45); z-index:1000; align-items:center; justify-content:center;">
    <div class="modal-card" style="width:min(520px,90vw); margin:40px auto; max-height: calc(100vh - 80px); overflow:hidden; border-radius:20px;">
        <div class="modal-title">è¯­éŸ³å…‹éš†</div>
        <div class="modal-divider"></div>
        <div class="modal-form">
            <label class="modal-label" for="voice-clone-file">å‚è€ƒéŸ³é¢‘</label>
            <input class="input-soft" type="file" id="voice-clone-file" accept="audio/*">
            <label class="modal-label" for="voice-clone-name">åç§°</label>
            <input class="input-soft" type="text" id="voice-clone-name" value="æˆ‘çš„å£°éŸ³" maxlength="32">
            <label class="modal-label" for="voice-clone-desc">æè¿°ï¼ˆå¯é€‰ï¼‰</label>
            <textarea class="input-soft" id="voice-clone-desc" rows="2" placeholder="å¦‚ï¼šæƒ…ç»ªå¹³ç¨³ã€æ— èƒŒæ™¯éŸ³"></textarea>
            <div class="voice-emotion-card emotion-panel">
                <div class="voice-emotion-header">
                    <div class="voice-emotion-title">è®¾å®šæƒ…æ„Ÿå‚æ•°</div>
                    <button class="voice-emotion-reset secondary-btn" id="voice-emotion-reset" type="button">é‡ç½®</button>
                </div>
                <div class="voice-emotion-sliders">
                    <div class="voice-emotion-item emotion-row"><span class="emotion-label">å¼€å¿ƒ</span><input type="range" min="0" max="1" step="0.1" value="0" data-voice-emotion="happy"><span class="voice-emotion-value emotion-value" data-voice-emotion-value="happy">0</span></div>
                    <div class="voice-emotion-item emotion-row"><span class="emotion-label">æ„¤æ€’</span><input type="range" min="0" max="1" step="0.1" value="0" data-voice-emotion="angry"><span class="voice-emotion-value emotion-value" data-voice-emotion-value="angry">0</span></div>
                    <div class="voice-emotion-item emotion-row"><span class="emotion-label">æ‚²ä¼¤</span><input type="range" min="0" max="1" step="0.1" value="0" data-voice-emotion="sad"><span class="voice-emotion-value emotion-value" data-voice-emotion-value="sad">0</span></div>
                    <div class="voice-emotion-item emotion-row"><span class="emotion-label">å®³æ€•</span><input type="range" min="0" max="1" step="0.1" value="0" data-voice-emotion="afraid"><span class="voice-emotion-value emotion-value" data-voice-emotion-value="afraid">0</span></div>
                    <div class="voice-emotion-item emotion-row"><span class="emotion-label">åŒæ¶</span><input type="range" min="0" max="1" step="0.1" value="0" data-voice-emotion="disgusted"><span class="voice-emotion-value emotion-value" data-voice-emotion-value="disgusted">0</span></div>
                    <div class="voice-emotion-item emotion-row"><span class="emotion-label">å¿§éƒ</span><input type="range" min="0" max="1" step="0.1" value="0" data-voice-emotion="melancholic"><span class="voice-emotion-value emotion-value" data-voice-emotion-value="melancholic">0</span></div>
                    <div class="voice-emotion-item emotion-row"><span class="emotion-label">æƒŠè®¶</span><input type="range" min="0" max="1" step="0.1" value="0" data-voice-emotion="surprised"><span class="voice-emotion-value emotion-value" data-voice-emotion-value="surprised">0</span></div>
                    <div class="voice-emotion-item emotion-row"><span class="emotion-label">å¹³é™</span><input type="range" min="0" max="1" step="0.1" value="0" data-voice-emotion="calm"><span class="voice-emotion-value emotion-value" data-voice-emotion-value="calm">0</span></div>
                </div>
            </div>
            <div id="voice-clone-status"></div>
            <button class="primary-btn" id="voice-clone-action" type="button">ä¸Šä¼ /åˆ›å»º</button>
            <button class="secondary-btn" data-modal-close type="button">å…³é—­</button>
        </div>
    </div>
</div>
<div id="toast" class="toast"></div>

<script src="/static/js/pro_api_logic.js"></script>
<script>
let currentUserId = "";
let currentRound = 0;
const chatHistory = [];

const STORAGE_VOICE_AUDIO_ID = "voice_audio_id";
const STORAGE_VOICE_OUTPUT = "voice_output_enabled";
const voiceCloneTriggers = document.querySelectorAll('[data-voice-clone-trigger]');
const voiceCloneModal = document.getElementById('voice-clone-modal');
const voiceCloneAction = document.getElementById('voice-clone-action');
const voiceCloneFile = document.getElementById('voice-clone-file');
const voiceCloneName = document.getElementById('voice-clone-name');
const voiceCloneDesc = document.getElementById('voice-clone-desc');
const voiceCloneStatus = document.getElementById('voice-clone-status');
const voiceEmotionReset = document.getElementById('voice-emotion-reset');
const voiceOutputToggle = document.getElementById('voice-output-toggle');
const voiceStopBtn = document.getElementById('voice-stop-btn');
const isProPlan = true;
let voiceOutputEnabled = false;
let ttsActive = false;
let ttsAudio = null;
let ttsAudioUrl = null;
let ttsAbortControllers = new Set();
let ttsToken = 0;
let ttsUnlocked = false;
let ttsUnlockHinted = false;
const isiOS = /iP(ad|hone|od)/.test(navigator.userAgent)
    || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

function safeLocalStorageSet(key, value) {
    try {
        localStorage.setItem(key, value);
    } catch (e) {
    }
}

function safeLocalStorageGet(key) {
    try {
        return localStorage.getItem(key);
    } catch (e) {
        return "";
    }
}

let toastTimer = null;
function showToast(text, duration=2000) {
    const toast = document.getElementById("toast");
    toast.innerText = text;
    toast.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => {
        toast.classList.remove("show");
    }, duration);
}

function hideToast() {
    const toast = document.getElementById("toast");
    if (toast) toast.classList.remove("show");
    if (toastTimer) clearTimeout(toastTimer);
}

function showErrorModal(message) {
    showToast(message || "æœåŠ¡æš‚ä¸å¯ç”¨");
}

function openModal(modal) {
    if (!modal) return;
    modal.style.display = 'block';
}

function closeModal(modal) {
    if (!modal) return;
    modal.style.display = 'none';
}

function closeAllModals() {
    document.querySelectorAll('#voice-clone-modal').forEach((modal) => {
        closeModal(modal);
    });
}

function createDefaultEmotionState() {
    return {
        happy: 0,
        angry: 0,
        sad: 0,
        afraid: 0,
        disgusted: 0,
        melancholic: 0,
        surprised: 0,
        calm: 0
    };
}

let emotionParams = {
    happy: 0,
    angry: 0,
    sad: 0,
    afraid: 0,
    disgusted: 0,
    melancholic: 0,
    surprised: 0,
    calm: 0
};

function resetEmotion() {
    emotionParams = createDefaultEmotionState();
    document.querySelectorAll('[data-voice-emotion]').forEach((input) => {
        const key = input.dataset.voiceEmotion;
        const value = emotionParams[key] || 0;
        input.value = value;
        const display = document.querySelector(`[data-voice-emotion-value="${key}"]`);
        if (display) display.innerText = value;
    });
}

function clampEmotionValue(value) {
    if (!Number.isFinite(value)) return 0;
    return Math.min(1, Math.max(0, Math.round(value * 10) / 10));
}

function buildVoiceCloneEmotionParams() {
    const params = {};
    const baseState = createDefaultEmotionState();
    Object.keys(baseState).forEach((key) => {
        params[key] = clampEmotionValue(Number(emotionParams[key] ?? 0));
    });
    return params;
}

function requestVoiceClone(payload) {
    return ProApiLogic.fetchJson("/api/voice_clone/reference/upload", {
        method: "POST",
        body: payload
    });
}

function setVoiceCloneStatus(message, type = "") {
    if (!voiceCloneStatus) return;
    voiceCloneStatus.textContent = message || "";
    voiceCloneStatus.className = "";
    if (type) {
        voiceCloneStatus.classList.add(type);
    }
}

function loadEmotionState() {
    resetEmotion();
}

function applyEmotionState(nextState) {
    emotionParams = { ...createDefaultEmotionState(), ...nextState };
}

async function parseErrorMessage(res) {
    const fallback = "æœåŠ¡æš‚ä¸å¯ç”¨";
    if (!res) return fallback;
    const contentType = res.headers.get("content-type") || "";
    if (contentType.includes("application/json")) {
        try {
            const data = await res.json();
            return data?.msg || fallback;
        } catch (e) {
            return fallback;
        }
    }
    try {
        const text = await res.text();
        if (text) return text.length > 160 ? `${text.slice(0, 160)}...` : text;
    } catch (e) {
    }
    return fallback;
}

async function parseErrorPayload(res) {
    if (!res) return { msg: "æœåŠ¡æš‚ä¸å¯ç”¨", detail: null };
    const contentType = res.headers.get("content-type") || "";
    if (contentType.includes("application/json")) {
        try {
            const data = await res.json();
            return { msg: data?.msg || "æœåŠ¡æš‚ä¸å¯ç”¨", detail: data?.detail };
        } catch (e) {
            return { msg: "æœåŠ¡æš‚ä¸å¯ç”¨", detail: null };
        }
    }
    try {
        const text = await res.text();
        if (text) return { msg: text.length > 160 ? `${text.slice(0, 160)}...` : text, detail: null };
    } catch (e) {
    }
    return { msg: "æœåŠ¡æš‚ä¸å¯ç”¨", detail: null };
}

function buildVoiceEmotionExt() {
    const emotionKeys = ["happy", "angry", "sad", "afraid", "disgusted", "melancholic", "surprised", "calm"];
    let sourceState = emotionParams;
    if (window.currentTtsExt && typeof window.currentTtsExt === "object") {
        sourceState = window.currentTtsExt;
    }
    if (sourceState?.surprise !== undefined && sourceState?.surprised === undefined) {
        sourceState = { ...sourceState, surprised: sourceState.surprise };
        delete sourceState.surprise;
    }
    const ext = {};
    const base = sourceState || {};
    const speedValue = Number(base.speed);
    const pitchValue = Number(base.pitch);
    const volumeValue = Number(base.volume);
    if (Number.isFinite(speedValue) && Math.abs(speedValue - 1) > 0.001) ext.speed = speedValue;
    if (Number.isFinite(pitchValue) && Math.abs(pitchValue - 1) > 0.001) ext.pitch = pitchValue;
    if (Number.isFinite(volumeValue) && Math.abs(volumeValue - 1) > 0.001) ext.volume = volumeValue;
    emotionKeys.forEach((key) => {
        const numericValue = Number(base[key]);
        if (!Number.isFinite(numericValue)) return;
        const clamped = Math.min(1, Math.max(0, numericValue));
        if (clamped > 0) ext[key] = clamped;
    });
    return ext;
}

function initVoiceOutputToggle() {
    if (!voiceOutputToggle) return;
    const stored = safeLocalStorageGet(STORAGE_VOICE_OUTPUT);
    voiceOutputEnabled = stored === "1";
    voiceOutputToggle.classList.toggle('on', voiceOutputEnabled);
    voiceOutputToggle.classList.toggle('off', !voiceOutputEnabled);
    voiceOutputToggle.setAttribute('aria-checked', voiceOutputEnabled ? 'true' : 'false');
}

function setVoiceOutputEnabled(nextValue) {
    voiceOutputEnabled = Boolean(nextValue);
    safeLocalStorageSet(STORAGE_VOICE_OUTPUT, voiceOutputEnabled ? "1" : "0");
    if (voiceOutputToggle) {
        voiceOutputToggle.classList.toggle('on', voiceOutputEnabled);
        voiceOutputToggle.classList.toggle('off', !voiceOutputEnabled);
        voiceOutputToggle.setAttribute('aria-checked', voiceOutputEnabled ? 'true' : 'false');
    }
    if (!voiceOutputEnabled) {
        resetTtsQueue();
    }
    showToast(voiceOutputEnabled ? "è¯­éŸ³è¾“å‡ºå·²å¼€å¯" : "è¯­éŸ³è¾“å‡ºå·²å…³é—­");
}

function resetTtsQueue() {
    ttsToken += 1;
    ttsActive = false;
    if (ttsAbortControllers.size) {
        ttsAbortControllers.forEach((controller) => controller.abort());
        ttsAbortControllers.clear();
    }
    if (ttsAudio) {
        ttsAudio.pause();
        ttsAudio.removeAttribute('src');
        ttsAudio.load();
    }
    if (ttsAudioUrl) {
        URL.revokeObjectURL(ttsAudioUrl);
        ttsAudioUrl = null;
    }
    hideToast();
    if (voiceStopBtn) {
        voiceStopBtn.disabled = true;
    }
}

function ensureTtsAudio() {
    if (ttsAudio) return;
    ttsAudio = new Audio();
    ttsAudio.preload = "auto";
    ttsAudio.setAttribute("playsinline", "");
    ttsAudio.setAttribute("webkit-playsinline", "");
}

function unlockTtsForIOS() {
    if (!voiceOutputEnabled || ttsUnlocked) return;
    ensureTtsAudio();
    if (!ttsAudio) return;
    const silentWav = "data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=";
    ttsAudio.muted = true;
    ttsAudio.src = silentWav;
    const playPromise = ttsAudio.play();
    if (playPromise && typeof playPromise.then === "function") {
        playPromise.then(() => {
            ttsAudio.pause();
            ttsAudio.currentTime = 0;
            ttsAudio.muted = false;
            ttsUnlocked = true;
        }).catch(() => {
            ttsAudio.muted = false;
        });
    } else {
        ttsAudio.muted = false;
        ttsUnlocked = true;
    }
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function requestVoiceCloneTts(text, token) {
    if (!ProApiLogic.isValidUserId(currentUserId)) throw new Error("user_id_invalid");
    const ext = buildVoiceEmotionExt();
    const extPayload = Object.keys(ext).length ? ext : {};
    console.log("[TTS] extPayload =", extPayload);
    const { speed: extSpeed, ...extWithoutSpeed } = extPayload;
    const requestPayload = { user_id: currentUserId, text: text, ext: extWithoutSpeed };
    if (Number.isFinite(extSpeed)) requestPayload.speed = extSpeed;
    const controller = new AbortController();
    ttsAbortControllers.add(controller);
    try {
        const createRes = await fetch("/api/voice_clone/tts/create", {
            method: "POST", headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ ...requestPayload }), signal: controller.signal
        });
        if (token !== ttsToken) {
            const cancelError = new Error("tts_cancelled");
            cancelError.name = "AbortError";
            throw cancelError;
        }
        if (!createRes.ok) throw new Error((await parseErrorMessage(createRes)) || "è¯­éŸ³åˆæˆå¤±è´¥");
        const createPayload = await createRes.json();
        if (!createPayload.ok || !createPayload.taskId) throw new Error(createPayload.msg || "è¯­éŸ³åˆæˆå¤±è´¥");
        const taskId = createPayload.taskId;
        const timeoutMs = 60000;
        const start = Date.now();
        let voiceUrl = "";
        let waitMs = 400;
        while (Date.now() - start < timeoutMs) {
            if (token !== ttsToken) {
                const cancelError = new Error("tts_cancelled");
                cancelError.name = "AbortError";
                throw cancelError;
            }
            const resultRes = await fetch(`/api/voice_clone/tts/result?user_id=${encodeURIComponent(currentUserId)}&taskId=${encodeURIComponent(taskId)}`, {
                method: "GET", signal: controller.signal
            });
            if (!resultRes.ok) throw new Error((await parseErrorMessage(resultRes)) || "è¯­éŸ³åˆæˆå¤±è´¥");
            const resultPayload = await resultRes.json();
            if (!resultPayload.ok) throw new Error(resultPayload.msg || "è¯­éŸ³åˆæˆå¤±è´¥");
            const status = resultPayload.status;
            if (status === 1) {
                await sleep(waitMs);
                waitMs = Math.min(waitMs + 200, 1000);
                continue;
            }
            if (status === 2 && resultPayload.voiceUrl) {
                voiceUrl = resultPayload.voiceUrl;
                break;
            }
            if (status === 3) throw new Error("è¯­éŸ³åˆæˆå¤±è´¥");
        }
        if (!voiceUrl) throw new Error("ç”Ÿæˆè¾ƒæ…¢ï¼Œå¯ç¨åé‡è¯•");
        const audioRes = await fetch(`/api/voice_clone/tts/audio?voiceUrl=${encodeURIComponent(voiceUrl)}`, {
            method: "GET", signal: controller.signal
        });
        if (!audioRes.ok) throw new Error((await parseErrorMessage(audioRes)) || "è¯­éŸ³åˆæˆå¤±è´¥");
        const contentType = audioRes.headers.get("content-type") || "";
        if (!contentType.startsWith("audio/") && contentType !== "application/octet-stream") {
            const { msg, detail } = await parseErrorPayload(audioRes);
            showToast(msg || "è¯­éŸ³åˆæˆå¤±è´¥");
            if (detail) console.warn("è¯­éŸ³åˆæˆè¿”å›ééŸ³é¢‘", detail);
            else console.warn("è¯­éŸ³åˆæˆè¿”å›ééŸ³é¢‘");
            const err = new Error(msg || "è¯­éŸ³åˆæˆå¤±è´¥");
            err.name = "TtsNonAudioError";
            throw err;
        }
        return audioRes;
    } finally {
        ttsAbortControllers.delete(controller);
    }
}

async function handleVoiceCloneUpload() {
    if (!voiceCloneFile || !voiceCloneAction) return;
    if (!ProApiLogic.isValidUserId(currentUserId)) {
        setVoiceCloneStatus("èº«ä»½å¤±æ•ˆï¼Œè¯·é‡æ–°ç™»å½•", "error");
        showToast("èº«ä»½å¤±æ•ˆï¼Œè¯·é‡æ–°ç™»å½•");
        return;
    }
    const file = voiceCloneFile.files?.[0];
    if (!file) {
        setVoiceCloneStatus("è¯·å…ˆé€‰æ‹©éŸ³é¢‘æ–‡ä»¶", "error");
        showToast("è¯·å…ˆé€‰æ‹©éŸ³é¢‘æ–‡ä»¶");
        return;
    }
    const name = (voiceCloneName?.value || "").trim() || "æˆ‘çš„å£°éŸ³";
    const describe = (voiceCloneDesc?.value || "").trim();
    const formData = new FormData();
    formData.append("file", file);
    formData.append("name", name);
    formData.append("describe", describe);
    formData.append("user_id", currentUserId);
    formData.append("emotion_params", JSON.stringify(buildVoiceCloneEmotionParams()));

    voiceCloneAction.disabled = true;
    setVoiceCloneStatus("ä¸Šä¼ ä¸­ï¼Œè¯·ç¨å€™...");

    try {
        const data = await requestVoiceClone(formData);
        if (data?.ok && data.data?.audioId) {
            const audioId = data.data.audioId;
            setVoiceCloneStatus(`ä¸Šä¼ æˆåŠŸï¼šaudioId=${audioId}`, "success");
            if (isProPlan) {
                safeLocalStorageSet(STORAGE_VOICE_AUDIO_ID, audioId);
            }
            showToast("è¯­éŸ³å…‹éš†ä¸Šä¼ æˆåŠŸ");
            return;
        }
        const errorMsg = data?.msg || "ä¸Šä¼ å¤±è´¥";
        setVoiceCloneStatus(errorMsg, "error");
        showErrorModal(errorMsg);
    } finally {
        voiceCloneAction.disabled = false;
    }
}

const input = document.getElementById("input");
const sendBtn = document.getElementById("sendBtn");
const chat = document.getElementById("chat");

/* å¯ç”¨å‘é€æŒ‰é’® */
input.addEventListener("input", () => {
    if(input.value.trim().length > 0){
        sendBtn.disabled = false;
        sendBtn.classList.add("active");
    }else{
        sendBtn.disabled = true;
        sendBtn.classList.remove("active");
    }
});

/* æ·»åŠ æ¶ˆæ¯ */
function appendMessage(text, side){
    const msg = document.createElement("div");
    msg.className = "msg " + side;

    const avatar = document.createElement("div");
    avatar.className = "avatar";

    const bubble = document.createElement("div");
    bubble.className = "bubble";
    bubble.innerText = text;

    if(side === "left"){
        msg.appendChild(avatar);
        msg.appendChild(bubble);
    }else{
        msg.appendChild(bubble);
        msg.appendChild(avatar);
    }

    chat.appendChild(msg);
    chat.scrollTop = chat.scrollHeight;
    return bubble;
}

/* å‘é€é€»è¾‘ */
async function sendMessage(){
    const text = input.value.trim();
    if(!text) return;
    if(!ProApiLogic.isValidUserId(currentUserId)){
        showToast("èº«ä»½å¤±æ•ˆï¼Œè¯·é‡æ–°ç™»å½•");
        return;
    }

    let ttsRequestToken = null;
    if (voiceOutputEnabled) {
        unlockTtsForIOS();
        resetTtsQueue();
        ttsRequestToken = ttsToken;
    }

    appendMessage(text, "right");
    currentRound += 1;
    chatHistory.push({ role: "user", content: text, round_id: currentRound });

    input.value = "";
    sendBtn.disabled = true;
    sendBtn.classList.remove("active");

    const aiBubble = appendMessage("", "left");

    const result = await ProApiLogic.sendMessageAPI({
        userId: currentUserId,
        history: chatHistory,
        userInput: text,
        roundId: currentRound,
        onChunk: (_, fullText) => {
            aiBubble.innerText = fullText;
            chat.scrollTop = chat.scrollHeight;
        }
    });

    if(!result.ok){
        aiBubble.innerText = result.msg || "æœåŠ¡æš‚ä¸å¯ç”¨";
        return;
    }

    const finalText = (result.text || "").trim();
    if(!finalText){
        aiBubble.innerText = "æœåŠ¡æš‚ä¸å¯ç”¨";
        return;
    }
    if (voiceOutputEnabled && finalText) {
        try {
            ttsActive = true;
            if (voiceStopBtn) {
                voiceStopBtn.disabled = false;
            }
            showToast("è¯­éŸ³ç”Ÿæˆä¸­...");
            const res = await requestVoiceCloneTts(finalText, ttsRequestToken);
            if (ttsRequestToken !== ttsToken) return;
            const blob = await res.blob();
            if (ttsRequestToken !== ttsToken) return;
            ensureTtsAudio();
            const url = URL.createObjectURL(blob);
            try {
                if (ttsAudioUrl) {
                    URL.revokeObjectURL(ttsAudioUrl);
                }
                ttsAudioUrl = url;
                ttsAudio.src = url;
                let cleanup = () => {};
                const playEnded = new Promise((resolve, reject) => {
                    const onEnd = () => { cleanup(); resolve(); };
                    const onError = () => { cleanup(); reject(new Error("audio_error")); };
                    cleanup = () => {
                        ttsAudio.removeEventListener("ended", onEnd);
                        ttsAudio.removeEventListener("error", onError);
                    };
                    ttsAudio.addEventListener("ended", onEnd);
                    ttsAudio.addEventListener("error", onError);
                });
                const playPromise = ttsAudio.play();
                if (playPromise && typeof playPromise.then === "function") {
                    try {
                        await playPromise;
                        hideToast();
                    } catch (playError) {
                        cleanup();
                        hideToast();
                        throw playError;
                    }
                } else {
                    hideToast();
                }
                await playEnded;
            } finally {
                if (ttsAudioUrl === url) {
                    URL.revokeObjectURL(url);
                    ttsAudioUrl = null;
                }
            }
        } catch (err) {
            const errorName = err?.name || "";
            const errorMessage = err?.message || "è¯­éŸ³åˆæˆå¤±è´¥";
            if (errorName === "NotAllowedError") {
                if (!ttsUnlockHinted) {
                    ttsUnlockHinted = true;
                    showToast("è¯·å…ˆç‚¹å‡»å‘é€æŒ‰é’®ä»¥å¯ç”¨è¯­éŸ³æ’­æ”¾");
                }
            } else if (errorName === "AbortError") {
            } else if (errorName === "TtsNonAudioError") {
            } else {
                showToast(errorMessage);
            }
            console.warn("è¯­éŸ³åˆæˆå¤±è´¥", err);
        } finally {
            hideToast();
            if (ttsRequestToken === ttsToken) {
                ttsActive = false;
                if (voiceStopBtn) {
                    voiceStopBtn.disabled = true;
                }
            }
        }
    }
    chatHistory.push({ role: "assistant", content: finalText, round_id: currentRound });
    loadEmotion(text);
}

sendBtn.addEventListener("click", sendMessage);

/* Enterå‘é€ï¼ŒShift+Enteræ¢è¡Œ */
input.addEventListener("keydown", function(e){
    if(e.key === "Enter" && !e.shiftKey){
        e.preventDefault();
        sendMessage();
    }
});

const overlay = document.getElementById("overlay");
const drawer = document.getElementById("drawer");
const menuBtn = document.getElementById("menuBtn");

menuBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    overlay.classList.toggle("show");
});

/* ç‚¹å‡»é®ç½©å…³é—­ */
overlay.addEventListener("click", () => {
    overlay.classList.remove("show");
});

/* æŠ½å±‰å†…éƒ¨ç‚¹å‡»ä¸å…³é—­ */
drawer.addEventListener("click", (e) => {
    e.stopPropagation();
});
if (voiceOutputToggle) {
    voiceOutputToggle.addEventListener("click", () => {
        voiceOutputEnabled = !voiceOutputEnabled;
        voiceOutputToggle.classList.toggle("on", voiceOutputEnabled);
    });
}

document.querySelectorAll('[data-voice-emotion]').forEach((input) => {
    input.addEventListener('input', (event) => {
        const target = event.currentTarget;
        const key = target.dataset.voiceEmotion;
        const value = clampEmotionValue(Number(target.value));
        emotionParams[key] = value;
        target.value = value;
        const display = document.querySelector(`[data-voice-emotion-value="${key}"]`);
        if (display) display.innerText = value.toFixed(1).replace(/\.0$/, "");
    });
});

if (voiceEmotionReset) {
    voiceEmotionReset.addEventListener('click', () => {
        resetEmotion();
    });
}

if (voiceStopBtn) {
    voiceStopBtn.addEventListener('click', () => {
        resetTtsQueue();
        showToast("å·²åœæ­¢æ’­æŠ¥");
    });
}

async function loadProfile(){
    const ctx = await ProApiLogic.getUserContext();
    if(!ctx.isValidUserId) return;
    currentUserId = ctx.user_id;
    const nameNode = document.querySelector(".username");
    if(nameNode){
        nameNode.textContent = (ctx.profile?.display_name || "").trim() || currentUserId.slice(-6);
    }
}

async function loadEmotion(currentInput = ""){
    if(!ProApiLogic.isValidUserId(currentUserId)) return;
    const result = await ProApiLogic.analyzeEmotionAPI({
        userId: currentUserId,
        history: chatHistory,
        currentInput,
        roundId: currentRound
    });
    if(!result.ok) return;
    const score = Number(result.data.score || 0);
    const scoreNode = document.querySelector(".score-row span:last-child");
    if(scoreNode){
        scoreNode.textContent = `${score} / 100`;
    }
    const bar = document.querySelector(".progress-bar");
    if(bar){
        bar.style.width = `${score}%`;
    }
}

if (voiceCloneTriggers.length) {
    voiceCloneTriggers.forEach((btn) => {
        btn.addEventListener('click', () => {
            setVoiceCloneStatus("");
            loadEmotionState();
            openModal(voiceCloneModal);
        });
    });
}

if (voiceCloneAction) {
    voiceCloneAction.addEventListener('click', () => {
        handleVoiceCloneUpload();
    });
}

document.querySelectorAll('[data-modal-close]').forEach((btn) => {
    btn.addEventListener('click', () => {
        closeAllModals();
    });
});

if (voiceCloneModal) {
    voiceCloneModal.addEventListener('click', (event) => {
        if (event.target === voiceCloneModal) {
            closeModal(voiceCloneModal);
        }
    });
}

loadProfile();
loadEmotion();
initVoiceOutputToggle();
resetEmotion();
</script>

</body>
</html>
