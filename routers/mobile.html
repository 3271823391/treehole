<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chat UI</title>

<style>
    .drawer-inner{
    flex:1;
    overflow-y:auto;
    padding:20px;
    background:#ededed;
}

/* å¤´åƒåŒºåŸŸ */
.profile-section{
    display:flex;
    align-items:center;
    margin-bottom:25px;
}

.avatar-large{
    width:64px;
    height:64px;
    border-radius:12px;
    background:#d8d8d8;
    margin-right:15px;
}

.nickname{
    font-size:18px;
    font-weight:600;
    margin-bottom:5px;
}

.profile-tip{
    font-size:12px;
    color:#999;
}

/* è®¾ç½®è¡Œ */
.setting-row{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:15px 0;
    border-bottom:1px solid #eee;
}

/* å¼€å…³æ ·å¼ */
.switch{
    position:relative;
    display:inline-block;
    width:42px;
    height:22px;
}

.switch input{
    display:none;
}

.slider{
    position:absolute;
    cursor:pointer;
    top:0; left:0;
    right:0; bottom:0;
    background:#ccc;
    border-radius:22px;
    transition:.3s;
}

.slider:before{
    position:absolute;
    content:"";
    height:18px;
    width:18px;
    left:2px;
    bottom:2px;
    background:white;
    border-radius:50%;
    transition:.3s;
}

input:checked + .slider{
    background:#07c160;
}

input:checked + .slider:before{
    transform:translateX(20px);
}

/* å¡ç‰‡ */
.card{
    background:white;
    border-radius:16px;
    padding:15px;
    margin-top:20px;
    box-shadow:0 2px 8px rgba(0,0,0,0.05);
}

.card-title{
    font-weight:600;
    margin-bottom:15px;
    color:#333;
}

.emotion-score{
    display:flex;
    justify-content:space-between;
    margin-bottom:10px;
}

.progress-bar{
    height:8px;
    background:#eee;
    border-radius:8px;
    overflow:hidden;
    margin-bottom:10px;
}

.progress-inner{
    height:100%;
    background:linear-gradient(90deg,#ff7a7a,#6b8cff);
}

.emotion-tags span{
    display:inline-block;
    background:#eef2ff;
    padding:5px 12px;
    border-radius:20px;
    font-size:12px;
    margin-right:6px;
    color:#4a6cff;
}

.emotion-text{
    font-size:13px;
    color:#555;
    margin-top:10px;
}

.primary-btn{
    width:100%;
    height:44px;
    background:#4a6cff;
    border:none;
    color:white;
    border-radius:22px;
    font-size:14px;
    cursor:pointer;
}
html, body{
    margin:0;
    padding:0;
    height:100%;
    background:#f5f5f5;
    font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto;
}

.phone{
    width:100%;
    height:100dvh;
    display:flex;
    flex-direction:column;
    overflow:hidden;

}
.header{
    height:60px;
    background:#ffffff;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:600;
    border-bottom:1px solid #e5e5e5;
    position:relative;
}

.back-btn{
    position:absolute;
    left:15px;
    background:none;
    border:none;
    font-size:16px;
    cursor:pointer;
}

.menu-btn{
    position:absolute;
    right:15px;
    background:none;
    border:none;
    font-size:24px;
    cursor:pointer;
    color:#333;
}

.chat{
    flex:1;
    padding:15px;
    overflow-y:auto;
}

.msg{
    display:flex;
    margin-bottom:15px;
    align-items:flex-end;
}

.msg.left{justify-content:flex-start;}
.msg.right{justify-content:flex-end;}

.avatar-msg{
    width:32px;
    height:32px;
    border-radius:6px;
    background:#ccc;
}

.msg.left .avatar-msg{
    margin-right:8px;
}

.msg.right .avatar-msg{
    margin-left:8px;
    order:2;
}

.bubble{
    max-width:70%;
    padding:10px 14px;
    border-radius:16px;
    font-size:15px;
    line-height:1.4;
    word-break:break-word;
}

.left .bubble{
    background:white;
}

.right .bubble{
    background:#9fe870;
}

.input-area{
    height:48px;
    background:#ffffff;
    display:flex;
    align-items:center;
    padding:6px 12px;
    border-top:1px solid #ddd;
    gap:6px;
}
input{
    flex:1;
    height:36px;
    border-radius:4px;
    border:1px solid #e0e0e0;
    padding:0 14px;
    font-size:15px;
}

button.send{
    margin-left:10px;
    height:36px;
    border:none;
    background:#4caf50;
    color:white;
    border-radius:18px;
    padding:0 16px;
    cursor:pointer;
}

.drawer{
    position:fixed;
    top:0;
    right:0;
    width:100%;
    height:100dvh;
    background:#f5f5f5;
    transform:translateX(100%);
    transition:transform .32s cubic-bezier(.4,0,.2,1);
    z-index:1000;
    display:flex;
    flex-direction:column;
}

.drawer.open{
    transform:translateX(0);
}
.drawer-header{
    height:60px;
    background:#ffffff;
    display:flex;
    align-items:center;
    padding:0 15px;
    font-weight:600;
    border-bottom:1px solid #eee;
    flex-shrink:0;
}

.drawer-back{
    background:none;
    border:none;
    font-size:18px;
    margin-right:10px;
    cursor:pointer;
}
.more-btn{
    height:32px;
    width:32px;
    border:none;
    background:#eee;
    border-radius:6px;
    font-size:18px;
    cursor:pointer;
}
.overlay{
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100dvh;
    background:rgba(0,0,0,0.3);
    opacity:0;
    pointer-events:none;
    transition:0.3s;
    z-index:998;
}

.overlay.show{
    opacity:1;
    pointer-events:auto;
}
    /* ===== åº•éƒ¨åŠŸèƒ½é¢æ¿ï¼ˆå’Œ drawer å¹³çº§ï¼‰ ===== */
.bottom-panel{
    position:fixed;
    bottom:0;
    left:0;
    width:100%;
    height:30vh;
    background:#fff;
    border-top-left-radius:16px;
    border-top-right-radius:16px;
    box-shadow:0 -2px 8px rgba(0,0,0,0.05);
    transform:translateY(100%);
    transition:transform .32s cubic-bezier(.4,0,.2,1);
    z-index:1001;   /* æ¯” drawer é«˜ */
    display:flex;
    flex-direction:column;
}

.bottom-panel.open{
    transform:translateY(0);
}

.bottom-content{
    flex:1;
    padding:15px;
}
    .bottom-overlay{
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100dvh;
    background:rgba(0,0,0,0.3);
    opacity:0;
    pointer-events:none;
    transition:0.2s;
    z-index:1000;
}

.bottom-overlay.show{
    opacity:1;
    pointer-events:auto;
}
</style>
</head>

<body>

<div class="phone">
    <div class="header">
        <button class="back-btn">â†</button>
        èŠå¤©çª—å£
        <button class="menu-btn" onclick="toggleDrawer()">Â·Â·Â·</button>
    </div>

    <div class="chat" id="chat">
        <div class="msg left">
            <div class="avatar-msg"></div>
            <div class="bubble">ä½ å¥½ã€‚</div>
        </div>
    </div>

    <div class="input-area">
        <input id="input" placeholder="è¾“å…¥æ¶ˆæ¯...">
        <button class="send" onclick="sendMessage()">å‘é€</button>
        <button class="more-btn" onclick="toggleBottomPanel()">ï¼‹</button>
    </div>
</div>

<div class="drawer">

    <div class="drawer-header">
        <button class="drawer-back" onclick="toggleDrawer()">â†</button>
        <span>ä¸ªäººä¸­å¿ƒ</span>
    </div>

    <div class="drawer-inner">

        <!-- å¤´åƒåŒºåŸŸ -->
        <div class="profile-section">
            <div class="avatar-large"></div>
            <div class="profile-info">
                <div class="nickname" id="nickname">f298d8</div>
                <div class="profile-tip">èµ„æ–™ä¿®æ”¹è¯·å‰å¾€ç‰ˆæœ¬ä»‹ç»é¡µèœå•</div>
            </div>
        </div>

        <!-- è¯­éŸ³å¼€å…³ -->
        <div class="setting-row">
            <span>è¯­éŸ³è¾“å‡º</span>
            <button class="switch" id="voice-output-toggle" type="button" role="switch" aria-checked="false"></button>
        </div>

        <!-- æƒ…ç»ªåˆ†æå¡ç‰‡ -->
        <div class="card">
            <div class="card-title">ğŸ“Š æƒ…ç»ªåˆ†ææŠ¥å‘Š</div>

            <div class="emotion-score">
                <span>æƒ…ç»ªæŒ‡æ•°</span>
                <span id="emotionScore">60</span>/100
            </div>

            <div class="progress-bar">
                <div class="progress-inner" id="emotionBar" style="width:60%;"></div>
            </div>

            <div class="emotion-tags">
                <span>å¹³é™</span>
                <span>æœŸå¾…</span>
            </div>

            <div class="emotion-text">
                å½“å‰æœªæ£€æµ‹åˆ°æ˜æ˜¾çš„è´Ÿé¢æƒ…ç»ªï¼Œå¿ƒæ€å¹³ç¨³ã€‚
            </div>
        </div>

        <!-- è¯­éŸ³å…‹éš† -->
        <div class="card">
            <div class="card-title">ğŸ™ è¯­éŸ³å…‹éš†</div>
            <button class="primary-btn" id="voiceCloneBtn" data-voice-clone-trigger>
                è¯­éŸ³å…‹éš†
            </button>
        </div>

    </div>
</div>
<!-- åº•éƒ¨åŠŸèƒ½é¢æ¿ -->
<div class="bottom-overlay" id="bottomOverlay" onclick="closeBottomPanel()"></div>
<div class="bottom-panel" id="bottomPanel">

    <div class="bottom-content">
        åŠŸèƒ½åŒºåŸŸ
    </div>
</div>

<div class="bottom-overlay" id="voice-clone-modal" style="display:none;">
    <div class="card" style="margin: 24px; max-height: calc(100vh - 80px); overflow:auto;">
        <div class="card-title">è¯­éŸ³å…‹éš†</div>
        <div style="display:flex; flex-direction:column; gap:10px; margin-top:10px;">
            <label for="voice-clone-file">å‚è€ƒéŸ³é¢‘</label>
            <input type="file" id="voice-clone-file" accept="audio/*">
            <label for="voice-clone-name">åç§°</label>
            <input type="text" id="voice-clone-name" value="æˆ‘çš„å£°éŸ³" maxlength="32">
            <label for="voice-clone-desc">æè¿°ï¼ˆå¯é€‰ï¼‰</label>
            <textarea id="voice-clone-desc" rows="2" placeholder="å¦‚ï¼šæƒ…ç»ªå¹³ç¨³ã€æ— èƒŒæ™¯éŸ³"></textarea>
            <div id="voice-clone-status"></div>
            <button class="primary-btn" id="voice-clone-action" type="button">ä¸Šä¼ /åˆ›å»º</button>
            <button class="primary-btn" data-modal-close type="button">å…³é—­</button>
        </div>
    </div>
</div>
<script src="/static/js/pro_api_logic.js"></script>
<script>
let drawerOpen = false;
let bottomOpen = false;
let currentUserId = "";
let currentRound = 0;
const chatHistory = [];
const STORAGE_VOICE_AUDIO_ID = "voice_audio_id";
const STORAGE_VOICE_OUTPUT = "voice_output_enabled";

const voiceCloneTriggers = document.querySelectorAll('[data-voice-clone-trigger]');
const voiceCloneModal = document.getElementById('voice-clone-modal');
const voiceCloneAction = document.getElementById('voice-clone-action');
const voiceCloneFile = document.getElementById('voice-clone-file');
const voiceCloneName = document.getElementById('voice-clone-name');
const voiceCloneDesc = document.getElementById('voice-clone-desc');
const voiceCloneStatus = document.getElementById('voice-clone-status');
const voiceOutputToggle = document.getElementById('voice-output-toggle');
const voiceStopBtn = document.getElementById('voice-stop-btn');
const isProPlan = true;
let voiceOutputEnabled = false;
let ttsActive = false;
let ttsAudio = null;
let ttsAudioUrl = null;
let ttsAbortControllers = new Set();
let ttsToken = 0;
let ttsUnlocked = false;
let ttsUnlockHinted = false;
const isiOS = /iP(ad|hone|od)/.test(navigator.userAgent)
    || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

let toastTimer = null;

function safeLocalStorageSet(key, value) {
    try {
        localStorage.setItem(key, value);
    } catch (e) {
    }
}

function safeLocalStorageGet(key) {
    try {
        return localStorage.getItem(key);
    } catch (e) {
        return "";
    }
}

function showToast(message = "ç³»ç»Ÿé”™è¯¯", { duration = 2200 } = {}) {
    const toast = document.getElementById('mobile-toast');
    if (!toast) return;
    toast.innerText = message;
    toast.classList.add('show');
    if (toastTimer) {
        clearTimeout(toastTimer);
        toastTimer = null;
    }
    if (duration > 0) {
        toastTimer = setTimeout(() => {
            toast.classList.remove('show');
            toastTimer = null;
        }, duration);
    }
}

function hideToast() {
    const toast = document.getElementById('mobile-toast');
    if (!toast) return;
    toast.classList.remove('show');
    if (toastTimer) {
        clearTimeout(toastTimer);
        toastTimer = null;
    }
}

function showErrorModal(message) {
    showToast(message || "æœåŠ¡æš‚ä¸å¯ç”¨");
}

function openModal(modal) {
    if (!modal) return;
    modal.style.display = 'block';
}

function closeModal(modal) {
    if (!modal) return;
    modal.style.display = 'none';
}

function closeAllModals() {
    document.querySelectorAll('#voice-clone-modal').forEach((modal) => {
        closeModal(modal);
    });
}

function createDefaultEmotionState() {
    return {
        happy: 0,
        angry: 0,
        sad: 0,
        afraid: 0,
        disgusted: 0,
        melancholic: 0,
        surprised: 0,
        calm: 0
    };
}

let voiceEmotionState = createDefaultEmotionState();

function clampEmotionValue(value) {
    if (!Number.isFinite(value)) return 0;
    return Math.min(1, Math.max(0, Math.round(value * 10) / 10));
}

function buildVoiceCloneEmotionParams() {
    const params = {};
    const baseState = createDefaultEmotionState();
    Object.keys(baseState).forEach((key) => {
        params[key] = clampEmotionValue(Number(voiceEmotionState[key] ?? 0));
    });
    return params;
}

function requestVoiceClone(payload) {
    return ProApiLogic.fetchJson("/api/voice_clone/reference/upload", {
        method: "POST",
        body: payload
    });
}

function setVoiceCloneStatus(message, type = "") {
    if (!voiceCloneStatus) return;
    voiceCloneStatus.textContent = message || "";
    voiceCloneStatus.className = "";
    if (type) {
        voiceCloneStatus.classList.add(type);
    }
}

function loadEmotionState() {
    applyEmotionState(createDefaultEmotionState());
}

function applyEmotionState(nextState) {
    voiceEmotionState = { ...createDefaultEmotionState(), ...nextState };
}

async function parseErrorMessage(res) {
    const fallback = "æœåŠ¡æš‚ä¸å¯ç”¨";
    if (!res) return fallback;
    const contentType = res.headers.get("content-type") || "";
    if (contentType.includes("application/json")) {
        try {
            const data = await res.json();
            return data?.msg || fallback;
        } catch (e) {
            return fallback;
        }
    }
    try {
        const text = await res.text();
        if (text) return text.length > 160 ? `${text.slice(0, 160)}...` : text;
    } catch (e) {
    }
    return fallback;
}

async function parseErrorPayload(res) {
    if (!res) return { msg: "æœåŠ¡æš‚ä¸å¯ç”¨", detail: null };
    const contentType = res.headers.get("content-type") || "";
    if (contentType.includes("application/json")) {
        try {
            const data = await res.json();
            return {
                msg: data?.msg || "æœåŠ¡æš‚ä¸å¯ç”¨",
                detail: data?.detail
            };
        } catch (e) {
            return { msg: "æœåŠ¡æš‚ä¸å¯ç”¨", detail: null };
        }
    }
    try {
        const text = await res.text();
        if (text) {
            return {
                msg: text.length > 160 ? `${text.slice(0, 160)}...` : text,
                detail: null
            };
        }
    } catch (e) {
    }
    return { msg: "æœåŠ¡æš‚ä¸å¯ç”¨", detail: null };
}

function buildVoiceEmotionExt() {
    const emotionKeys = ["happy", "angry", "sad", "afraid", "disgusted", "melancholic", "surprised", "calm"];
    let sourceState = voiceEmotionState;
    if (window.currentTtsExt && typeof window.currentTtsExt === "object") {
        sourceState = window.currentTtsExt;
    }
    if (sourceState?.surprise !== undefined && sourceState?.surprised === undefined) {
        sourceState = { ...sourceState, surprised: sourceState.surprise };
        delete sourceState.surprise;
    }
    const ext = {};
    const base = sourceState || {};
    const speedValue = Number(base.speed);
    const pitchValue = Number(base.pitch);
    const volumeValue = Number(base.volume);
    if (Number.isFinite(speedValue) && Math.abs(speedValue - 1) > 0.001) ext.speed = speedValue;
    if (Number.isFinite(pitchValue) && Math.abs(pitchValue - 1) > 0.001) ext.pitch = pitchValue;
    if (Number.isFinite(volumeValue) && Math.abs(volumeValue - 1) > 0.001) ext.volume = volumeValue;
    emotionKeys.forEach((key) => {
        const numericValue = Number(base[key]);
        if (!Number.isFinite(numericValue)) return;
        const clamped = Math.min(1, Math.max(0, numericValue));
        if (clamped > 0) ext[key] = clamped;
    });
    return ext;
}

function initVoiceOutputToggle() {
    if (!voiceOutputToggle) return;
    const stored = safeLocalStorageGet(STORAGE_VOICE_OUTPUT);
    voiceOutputEnabled = stored === "1";
    voiceOutputToggle.classList.toggle('on', voiceOutputEnabled);
    voiceOutputToggle.classList.toggle('off', !voiceOutputEnabled);
    voiceOutputToggle.setAttribute('aria-checked', voiceOutputEnabled ? 'true' : 'false');
}

function setVoiceOutputEnabled(nextValue) {
    voiceOutputEnabled = Boolean(nextValue);
    safeLocalStorageSet(STORAGE_VOICE_OUTPUT, voiceOutputEnabled ? "1" : "0");
    if (voiceOutputToggle) {
        voiceOutputToggle.classList.toggle('on', voiceOutputEnabled);
        voiceOutputToggle.classList.toggle('off', !voiceOutputEnabled);
        voiceOutputToggle.setAttribute('aria-checked', voiceOutputEnabled ? 'true' : 'false');
    }
    if (!voiceOutputEnabled) {
        resetTtsQueue();
    }
    showToast(voiceOutputEnabled ? "è¯­éŸ³è¾“å‡ºå·²å¼€å¯" : "è¯­éŸ³è¾“å‡ºå·²å…³é—­");
}

function resetTtsQueue() {
    ttsToken += 1;
    ttsActive = false;
    if (ttsAbortControllers.size) {
        ttsAbortControllers.forEach((controller) => controller.abort());
        ttsAbortControllers.clear();
    }
    if (ttsAudio) {
        ttsAudio.pause();
        ttsAudio.removeAttribute('src');
        ttsAudio.load();
    }
    if (ttsAudioUrl) {
        URL.revokeObjectURL(ttsAudioUrl);
        ttsAudioUrl = null;
    }
    hideToast();
    if (voiceStopBtn) {
        voiceStopBtn.disabled = true;
    }
}

function ensureTtsAudio() {
    if (ttsAudio) return;
    ttsAudio = new Audio();
    ttsAudio.preload = "auto";
    ttsAudio.setAttribute("playsinline", "");
    ttsAudio.setAttribute("webkit-playsinline", "");
}

function unlockTtsForIOS() {
    if (!voiceOutputEnabled || ttsUnlocked) return;
    ensureTtsAudio();
    if (!ttsAudio) return;
    const silentWav = "data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=";
    ttsAudio.muted = true;
    ttsAudio.src = silentWav;
    const playPromise = ttsAudio.play();
    if (playPromise && typeof playPromise.then === "function") {
        playPromise.then(() => {
            ttsAudio.pause();
            ttsAudio.currentTime = 0;
            ttsAudio.muted = false;
            ttsUnlocked = true;
        }).catch(() => {
            ttsAudio.muted = false;
        });
    } else {
        ttsAudio.muted = false;
        ttsUnlocked = true;
    }
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function requestVoiceCloneTts(text, token) {
    if (!ProApiLogic.isValidUserId(currentUserId)) {
        throw new Error("user_id_invalid");
    }
    const ext = buildVoiceEmotionExt();
    const extPayload = Object.keys(ext).length ? ext : {};
    console.log("[TTS] extPayload =", extPayload);
    const { speed: extSpeed, ...extWithoutSpeed } = extPayload;
    const requestPayload = { user_id: currentUserId, text: text, ext: extWithoutSpeed };
    if (Number.isFinite(extSpeed)) {
        requestPayload.speed = extSpeed;
    }
    const controller = new AbortController();
    ttsAbortControllers.add(controller);
    try {
        const createRes = await fetch("/api/voice_clone/tts/create", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ ...requestPayload }),
            signal: controller.signal
        });
        if (token !== ttsToken) {
            const cancelError = new Error("tts_cancelled");
            cancelError.name = "AbortError";
            throw cancelError;
        }
        if (!createRes.ok) {
            const msg = await parseErrorMessage(createRes);
            throw new Error(msg || "è¯­éŸ³åˆæˆå¤±è´¥");
        }
        const createPayload = await createRes.json();
        if (!createPayload.ok || !createPayload.taskId) {
            throw new Error(createPayload.msg || "è¯­éŸ³åˆæˆå¤±è´¥");
        }
        const taskId = createPayload.taskId;
        const timeoutMs = 60000;
        const start = Date.now();
        let voiceUrl = "";
        let waitMs = 400;
        while (Date.now() - start < timeoutMs) {
            if (token !== ttsToken) {
                const cancelError = new Error("tts_cancelled");
                cancelError.name = "AbortError";
                throw cancelError;
            }
            const resultRes = await fetch(`/api/voice_clone/tts/result?user_id=${encodeURIComponent(currentUserId)}&taskId=${encodeURIComponent(taskId)}`, {
                method: "GET",
                signal: controller.signal
            });
            if (!resultRes.ok) {
                const msg = await parseErrorMessage(resultRes);
                throw new Error(msg || "è¯­éŸ³åˆæˆå¤±è´¥");
            }
            const resultPayload = await resultRes.json();
            if (!resultPayload.ok) {
                throw new Error(resultPayload.msg || "è¯­éŸ³åˆæˆå¤±è´¥");
            }
            const status = resultPayload.status;
            if (status === 1) {
                await sleep(waitMs);
                waitMs = Math.min(waitMs + 200, 1000);
                continue;
            }
            if (status === 2 && resultPayload.voiceUrl) {
                voiceUrl = resultPayload.voiceUrl;
                break;
            }
            if (status === 3) {
                throw new Error("è¯­éŸ³åˆæˆå¤±è´¥");
            }
        }
        if (!voiceUrl) {
            throw new Error("ç”Ÿæˆè¾ƒæ…¢ï¼Œå¯ç¨åé‡è¯•");
        }
        const audioRes = await fetch(`/api/voice_clone/tts/audio?voiceUrl=${encodeURIComponent(voiceUrl)}`, {
            method: "GET",
            signal: controller.signal
        });
        if (!audioRes.ok) {
            const msg = await parseErrorMessage(audioRes);
            throw new Error(msg || "è¯­éŸ³åˆæˆå¤±è´¥");
        }
        const contentType = audioRes.headers.get("content-type") || "";
        if (!contentType.startsWith("audio/") && contentType !== "application/octet-stream") {
            const { msg, detail } = await parseErrorPayload(audioRes);
            showToast(msg || "è¯­éŸ³åˆæˆå¤±è´¥");
            if (detail) {
                console.warn("è¯­éŸ³åˆæˆè¿”å›ééŸ³é¢‘", detail);
            } else {
                console.warn("è¯­éŸ³åˆæˆè¿”å›ééŸ³é¢‘");
            }
            const err = new Error(msg || "è¯­éŸ³åˆæˆå¤±è´¥");
            err.name = "TtsNonAudioError";
            throw err;
        }
        return audioRes;
    } finally {
        ttsAbortControllers.delete(controller);
    }
}

async function handleVoiceCloneUpload() {
    if (!voiceCloneFile || !voiceCloneAction) return;
    if (!ProApiLogic.isValidUserId(currentUserId)) {
        setVoiceCloneStatus("èº«ä»½å¤±æ•ˆï¼Œè¯·é‡æ–°ç™»å½•", "error");
        showToast("èº«ä»½å¤±æ•ˆï¼Œè¯·é‡æ–°ç™»å½•");
        return;
    }
    const file = voiceCloneFile.files?.[0];
    if (!file) {
        setVoiceCloneStatus("è¯·å…ˆé€‰æ‹©éŸ³é¢‘æ–‡ä»¶", "error");
        showToast("è¯·å…ˆé€‰æ‹©éŸ³é¢‘æ–‡ä»¶");
        return;
    }
    const name = (voiceCloneName?.value || "").trim() || "æˆ‘çš„å£°éŸ³";
    const describe = (voiceCloneDesc?.value || "").trim();
    const formData = new FormData();
    formData.append("file", file);
    formData.append("name", name);
    formData.append("describe", describe);
    formData.append("user_id", currentUserId);
    formData.append("emotion_params", JSON.stringify(buildVoiceCloneEmotionParams()));

    voiceCloneAction.disabled = true;
    setVoiceCloneStatus("ä¸Šä¼ ä¸­ï¼Œè¯·ç¨å€™...");

    try {
        const data = await requestVoiceClone(formData);
        if (data?.ok && data.data?.audioId) {
            const audioId = data.data.audioId;
            setVoiceCloneStatus(`ä¸Šä¼ æˆåŠŸï¼šaudioId=${audioId}`, "success");
            if (isProPlan) {
                safeLocalStorageSet(STORAGE_VOICE_AUDIO_ID, audioId);
            }
            showToast("è¯­éŸ³å…‹éš†ä¸Šä¼ æˆåŠŸ");
            return;
        }
        const errorMsg = data?.msg || "ä¸Šä¼ å¤±è´¥";
        setVoiceCloneStatus(errorMsg, "error");
        showErrorModal(errorMsg);
    } finally {
        voiceCloneAction.disabled = false;
    }
}

function toggleDrawer(){
    const drawer = document.querySelector(".drawer");

    if(!drawerOpen){
        drawer.classList.add("open");
        document.body.style.overflow = "hidden";

        history.pushState({drawer:true}, "");
        drawerOpen = true;
    }else{
        closeDrawer();
    }
}
function toggleBottomPanel(){
    const panel = document.getElementById("bottomPanel");
    const overlay = document.getElementById("bottomOverlay");

    if(!bottomOpen){
        panel.classList.add("open");
        overlay.classList.add("show");
        history.pushState({bottom:true}, "");
        bottomOpen = true;
    }else{
        closeBottomPanel();
    }
}

function closeBottomPanel(){
    document.getElementById("bottomPanel").classList.remove("open");
    document.getElementById("bottomOverlay").classList.remove("show");
    bottomOpen = false;
}

function closeDrawer(){
    const drawer = document.querySelector(".drawer");
    drawer.classList.remove("open");
    document.body.style.overflow = "";
    drawerOpen = false;
}

function appendMessage(text, side){
    const chat = document.getElementById("chat");
    const msg = document.createElement("div");
    msg.className = `msg ${side}`;
    if(side === "right"){
        msg.innerHTML = `
        <div class="bubble">${text}</div>
        <div class="avatar-msg"></div>
    `;
    }else{
        msg.innerHTML = `
        <div class="avatar-msg"></div>
        <div class="bubble">${text}</div>
    `;
    }
    chat.appendChild(msg);
    return msg;
}

async function sendMessage(){
    const input = document.getElementById("input");
    const text = input.value.trim();
    if(!text) return;
    if(!ProApiLogic.isValidUserId(currentUserId)){
        alert("èº«ä»½å¤±æ•ˆï¼Œè¯·é‡æ–°ç™»å½•");
        return;
    }

    let ttsRequestToken = null;
    if (voiceOutputEnabled) {
        unlockTtsForIOS();
        resetTtsQueue();
        ttsRequestToken = ttsToken;
    }

    appendMessage(text, "right");
    currentRound += 1;
    chatHistory.push({ role: "user", content: text, round_id: currentRound });
    input.value = "";
    scrollToBottom();

    const replyMsg = appendMessage("", "left");
    const bubble = replyMsg.querySelector(".bubble");

    const result = await ProApiLogic.sendMessageAPI({
        userId: currentUserId,
        history: chatHistory,
        userInput: text,
        roundId: currentRound,
        onChunk: (_, fullText) => {
            bubble.textContent = fullText;
            scrollToBottom();
        }
    });

    if(!result.ok){
        bubble.textContent = result.msg || "æœåŠ¡æš‚ä¸å¯ç”¨";
        return;
    }

    const finalText = (result.text || "").trim();
    if(!finalText){
        bubble.textContent = "æœåŠ¡æš‚ä¸å¯ç”¨";
        return;
    }
    let ttsPrefetchPromise = null;
    if (voiceOutputEnabled && finalText) {
        unlockTtsForIOS();
        resetTtsQueue();
        ttsRequestToken = ttsToken;
        ttsPrefetchPromise = requestVoiceCloneTts(finalText, ttsRequestToken);
    }

    chatHistory.push({ role: "assistant", content: finalText, round_id: currentRound });
    if (voiceOutputEnabled && finalText) {
        try {
            ttsActive = true;
            if (voiceStopBtn) {
                voiceStopBtn.disabled = false;
            }
            showToast("è¯­éŸ³ç”Ÿæˆä¸­â€¦", { duration: 0 });
            const res = await ttsPrefetchPromise;
            if (ttsRequestToken !== ttsToken) return;
            const blob = await res.blob();
            if (ttsRequestToken !== ttsToken) return;
            ensureTtsAudio();
            const url = URL.createObjectURL(blob);
            try {
                if (ttsAudioUrl) {
                    URL.revokeObjectURL(ttsAudioUrl);
                }
                ttsAudioUrl = url;
                ttsAudio.src = url;
                let cleanup = () => {};
                const playEnded = new Promise((resolve, reject) => {
                    const onEnd = () => { cleanup(); resolve(); };
                    const onError = () => { cleanup(); reject(new Error("audio_error")); };
                    cleanup = () => {
                        ttsAudio.removeEventListener("ended", onEnd);
                        ttsAudio.removeEventListener("error", onError);
                    };
                    ttsAudio.addEventListener("ended", onEnd);
                    ttsAudio.addEventListener("error", onError);
                });
                const playPromise = ttsAudio.play();
                if (playPromise && typeof playPromise.then === "function") {
                    try {
                        await playPromise;
                        hideToast();
                    } catch (playError) {
                        cleanup();
                        hideToast();
                        throw playError;
                    }
                } else {
                    hideToast();
                }
                await playEnded;
            } finally {
                if (ttsAudioUrl === url) {
                    URL.revokeObjectURL(url);
                    ttsAudioUrl = null;
                }
            }
        } catch (err) {
            const errorName = err?.name || "";
            const errorMessage = err?.message || "è¯­éŸ³åˆæˆå¤±è´¥";
            if (errorName === "NotAllowedError") {
                if (!ttsUnlockHinted) {
                    ttsUnlockHinted = true;
                    showToast("è¯·å…ˆç‚¹å‡»å‘é€æŒ‰é’®ä»¥å¯ç”¨è¯­éŸ³æ’­æ”¾");
                }
            } else if (errorName === "AbortError") {
            } else if (errorName === "TtsNonAudioError") {
            } else {
                showToast(errorMessage);
            }
            console.warn("è¯­éŸ³åˆæˆå¤±è´¥", err);
        } finally {
            hideToast();
            if (ttsRequestToken === ttsToken) {
                ttsActive = false;
                if (voiceStopBtn) {
                    voiceStopBtn.disabled = true;
                }
            }
        }
    }
    loadEmotion(text);
}

function scrollToBottom(){
    const chat = document.getElementById("chat");
    chat.scrollTop = chat.scrollHeight;
}
window.addEventListener("popstate", function(){
    if(bottomOpen){
        closeBottomPanel();
        return;
    }
    if(drawerOpen){
        closeDrawer();
    }
});
// å›è½¦å‘é€
document.getElementById("input").addEventListener("keydown", function(e){
    if(e.key === "Enter"){
        sendMessage();
    }
});

async function loadProfile(){
    const ctx = await ProApiLogic.getUserContext();
    if(ctx.isValidUserId){
        currentUserId = ctx.user_id;
        document.getElementById("nickname").textContent = (ctx.profile?.display_name || "").trim() || currentUserId.slice(-6);
    }
}

async function loadEmotion(currentInput = ""){
    if(!ProApiLogic.isValidUserId(currentUserId)) return;
    const result = await ProApiLogic.analyzeEmotionAPI({
        userId: currentUserId,
        history: chatHistory,
        currentInput,
        roundId: currentRound
    });

    if(!result.ok){
        return;
    }

    const score = Number(result.data.score || 0);
    document.getElementById("emotionScore").textContent = score;
    document.getElementById("emotionBar").style.width = score + "%";
}

if (voiceCloneTriggers.length) {
    voiceCloneTriggers.forEach((btn) => {
        btn.addEventListener('click', () => {
            setVoiceCloneStatus("");
            loadEmotionState();
            openModal(voiceCloneModal);
        });
    });
}

if (voiceCloneAction) {
    voiceCloneAction.addEventListener('click', () => {
        handleVoiceCloneUpload();
    });
}

if (voiceOutputToggle) {
    voiceOutputToggle.addEventListener('click', () => {
        setVoiceOutputEnabled(!voiceOutputEnabled);
    });
}

if (voiceStopBtn) {
    voiceStopBtn.addEventListener('click', () => {
        resetTtsQueue();
        showToast("å·²åœæ­¢æ’­æŠ¥");
    });
}

document.querySelectorAll('[data-modal-close]').forEach((btn) => {
    btn.addEventListener('click', () => {
        closeAllModals();
    });
});

if (voiceCloneModal) {
    voiceCloneModal.addEventListener('click', (event) => {
        if (event.target === voiceCloneModal) {
            closeModal(voiceCloneModal);
        }
    });
}

loadProfile();
loadEmotion();
initVoiceOutputToggle();
</script>

</body>
</html>
