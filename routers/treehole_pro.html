<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>å¿ƒçµé¿é£æ¸¯ - å°ç›ˆé™ªä½ è¯´å¿ƒé‡Œè¯</title>
    <link rel="stylesheet" href="/static/shared_shell.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Microsoft YaHei", "PingFang SC", sans-serif;
        }

        :root {
            --app-height: 100%;
            --vv-top: 0px;
            --footer-h: 56px;
        }

        html,
        body {
            height: 100%;
            margin: 0;
        }

        body {
            background-color: #f0f7ff;
            color: #333;
            overflow: hidden; /* TODO: iOS Safari é”®ç›˜å¼¹å‡ºæ—¶ä¿æŒå¸ƒå±€è§†å£ç¨³å®š */
        }

        /* å›ºå®šå¸ƒå±€å®¹å™¨ï¼šé¿å…é”®ç›˜å¼¹å‡ºå¯¼è‡´ footer è·³åŠ¨ */
        #appShell {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
        }

        /* é¡¶éƒ¨å¯¼èˆªæ  - ç§»é™¤AIæ ‘æ´ï¼Œç®€åŒ–æ–‡å­— */
        .header {
            background: linear-gradient(90deg, #4a90e2, #5ba0f2);
            color: #fff;
            padding: 1rem 2rem;
            text-align: center;
            box-shadow: 0 3px 15px rgba(74, 144, 226, 0.25);
            position: relative;
            z-index: 100;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .header-text {
            text-align: center;
        }

        .header h1 {
            font-size: 1.6rem;
            font-weight: 700;
            letter-spacing: 1px;
        }

        .header p {
            font-size: 0.9rem;
            opacity: 0.95;
            margin-top: 0.4rem;
        }

        .header-actions {
            display: none;
            gap: 0.6rem;
            align-items: center;
        }

        .header-action-btn {
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            border-radius: 999px;
            padding: 0.4rem 0.9rem;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .header-action-btn i {
            font-size: 0.95rem;
        }

        .header-action-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* ä¸»å®¹å™¨ - é‡æ„å¸ƒå±€ï¼ŒèŠå¤©æ¡†å ä¸»ä½“ */
        .main-container {
            flex: 1;
            display: flex;
            max-width: 1400px;
            margin: 1.2rem auto;
            padding: 0 1rem;
            gap: 1.2rem;
            flex-wrap: wrap;
            min-height: 0;
        }

        /* TODO: ä¸»å†…å®¹æ»šåŠ¨å®¹å™¨ï¼Œé¿å… footer è·Ÿéšæ»šåŠ¨ */
        #mainScroll {
            flex: 1;
            overflow: auto;
            -webkit-overflow-scrolling: touch;
            padding-bottom: calc(var(--footer-h, 56px) + env(safe-area-inset-bottom));
        }

        /* èŠå¤©åŒºåŸŸ - æå‡å æ¯”ï¼Œä¸»ä½“è§†è§‰ */
        .chat-section {
            flex: 4; /* èŠå¤©åŒºå 4ä»½ï¼Œä¾§è¾¹æ å 1ä»½ï¼Œä¸»ä½“æ›´çªå‡º */
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-height: 0;
        }

        /* èŠå¤©çª—å£ - ä¼˜åŒ–å†…è¾¹è·å’Œé˜´å½± */
        .chat-window {
            flex: 1;
            background-color: #fff;
            border-radius: 16px;
            padding: 1.2rem 1.5rem;
            box-shadow: 0 0 25px rgba(74, 144, 226, 0.08);
            overflow-y: auto;
            min-height: 0;
        }

        /* æ»šåŠ¨æ¡ç¾åŒ–å‡çº§ */
        .chat-window::-webkit-scrollbar {
            width: 7px;
        }
        .chat-window::-webkit-scrollbar-thumb {
            background-color: #c1d9ff;
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }
        .chat-window::-webkit-scrollbar-thumb:hover {
            background-color: #a3c1ff;
        }
        .chat-window::-webkit-scrollbar-track {
            background-color: #f8fbff;
        }

        /* æ¶ˆæ¯å®¹å™¨ - åŒ…å«å¤´åƒ+æ°”æ³¡ï¼Œå…³é”®å¸ƒå±€ */
        .msg-container {
            max-width: 80%;
            margin-bottom: 1.2rem;
            display: flex;
            align-items: flex-end;
            gap: 0.8rem;
        }

        /* å¤´åƒæ ·å¼ - åŒæ–¹ä¸“å±ï¼Œåœ†å½¢å¸¦è¾¹æ¡† */
        .msg-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            border: 2px solid #f0f7ff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .msg-avatar img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
            display: block;
        }
        /* ç”¨æˆ·å¤´åƒ - å³ä¾§æ¶ˆæ¯ï¼Œè“è‰²ç³» */
        .user-avatar {
            background-color: #4a90e2;
            color: #fff;
        }
        /* å°ç›ˆå¤´åƒ - å·¦ä¾§æ¶ˆæ¯ï¼Œæµ…è“ç³» */
        .ai-avatar {
            background-color: #e8f4ff;
            color: #4a90e2;
        }

        /* æ¶ˆæ¯æ°”æ³¡é€šç”¨ - ä¼˜åŒ–å†…è¾¹è·å’Œåœ†è§’ */
        .message {
            padding: 0.9rem 1.3rem;
            border-radius: 20px;
            line-height: 1.6;
            font-size: 0.95rem;
            position: relative;
            word-wrap: break-word;
        }

        /* ç”¨æˆ·æ¶ˆæ¯ - å³å¯¹é½ï¼Œè“è‰²æ°”æ³¡ï¼Œå¤´åƒåœ¨å³ */
        .user-msg-wrap {
            margin-left: auto;
            flex-direction: row-reverse; /* å¤´åƒåœ¨æ°”æ³¡å³ä¾§ */
        }
        .user-msg {
            background-color: #4a90e2;
            color: #fff;
            border-bottom-right-radius: 6px;
        }

        /* å°ç›ˆæ¶ˆæ¯ - å·¦å¯¹é½ï¼Œæµ…è“æ°”æ³¡ï¼Œå¤´åƒåœ¨å·¦ */
        .ai-msg-wrap {
            margin-right: auto;
        }
        .ai-msg {
            background-color: #e8f4ff;
            color: #333;
            border-bottom-left-radius: 6px;
        }

        /* åŠ è½½åŠ¨ç”» - é€‚é…å¤´åƒå¸ƒå±€ */
        .loading-wrap {
            margin-right: auto;
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }
        .loading {
            display: flex;
            gap: 4px;
            padding: 0.9rem 1rem;
            background-color: #e8f4ff;
            border-radius: 20px;
            border-bottom-left-radius: 6px;
        }
        .loading-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #4a90e2;
            animation: bounce 1s infinite alternate;
        }
        .loading-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        .loading-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(-6px); }
        }

        /* è¾“å…¥æ¡†åŒºåŸŸ - ä¼˜åŒ–åœ†è§’å’Œé˜´å½± */
        .composer {
            display: flex;
            gap: 0.8rem;
            align-items: center;
        }

        .input-area {
            display: flex;
            gap: 0.8rem;
            align-items: center;
            background-color: #fff;
            padding: 0.9rem 1.4rem;
            border-radius: 36px;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.08);
            flex: 1;
            min-height: 44px;
        }

        #msg-input {
            flex: 1;
            border: none;
            outline: none;
            background: transparent;
            font-size: 0.95rem;
            color: #333;
            resize: none;
            min-height: 20px;
            max-height: 120px;
            overflow-y: auto;
            padding: 0.3rem 0;
        }

        #msg-input::placeholder {
            color: #b0c4de;
        }

        .send-btn {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            background-color: #4a90e2;
            color: #fff;
            border: none;
            outline: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(74, 144, 226, 0.3);
        }

        .send-btn:disabled {
            background-color: #d0e1ff;
            cursor: not-allowed;
            box-shadow: none;
        }

        .send-btn:hover:not(:disabled) {
            background-color: #357bd8;
            transform: scale(1.05);
            box-shadow: 0 3px 10px rgba(74, 144, 226, 0.4);
        }

        .voice-clone-trigger {
            height: 44px;
            border-radius: 999px;
            padding: 0 1.2rem;
            font-size: 0.9rem;
            border: none;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            background: #e8f1ff;
            color: #3b6fb6;
            flex: 0 0 auto;
        }

        .voice-clone-trigger.primary {
            background-color: #4a90e2;
            color: #fff;
        }

        /* ä¾§è¾¹æ  - æ”¶çª„å®½åº¦ï¼Œè¾…åŠ©å¸ƒå±€ */
        .sidebar {
            flex: 1; /* ä¸èŠå¤©åŒº4:1æ¯”ä¾‹ï¼Œæ›´ç´§å‡‘ */
            min-width: 280px;
            display: flex;
            flex-direction: column;
            gap: 1.2rem;
        }

        .user-card {
            background-color: #fff;
            border-radius: 16px;
            padding: 1.4rem;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.08);
            height: auto;
            min-height: unset;
            overflow: visible;
            display: flex;
            flex-direction: column;
            gap: 0.9rem;
        }

        .user-card-header {
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        .user-card-title {
            font-weight: 600;
            font-size: 1rem;
            color: #3b6fb6;
        }

        .user-avatar-box {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid #e1ecff;
            flex-shrink: 0;
            cursor: pointer;
            background-color: #f0f7ff;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .user-avatar-box img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .user-card .form-row {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        .user-card label {
            font-size: 0.82rem;
            color: #6b7c93;
        }

        .label-with-tip {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .info-tip {
            position: relative;
            border: none;
            background: transparent;
            color: #8aa4cf;
            cursor: pointer;
            padding: 0;
            font-size: 0.85rem;
            line-height: 1;
        }

        .info-tip .tooltip {
            position: absolute;
            right: 0;
            top: 1.4rem;
            padding: 0.6rem 0.7rem;
            border-radius: 10px;
            background: #2f3b52;
            color: #fff;
            font-size: 0.78rem;
            line-height: 1.4;
            text-align: left;
            box-shadow: 0 8px 16px rgba(15, 25, 40, 0.2);
            opacity: 0;
            pointer-events: none;
            transform: translateY(-6px);
            transition: opacity 0.2s ease, transform 0.2s ease;
            z-index: 1200;
            max-width: 90vw;
            width: max-content;
            white-space: normal;
            word-break: break-word;
        }

        .info-tip:hover .tooltip,
        .info-tip:focus .tooltip,
        .info-tip:focus-within .tooltip {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        .info-tip.tooltip-open .tooltip {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        .user-card input {
            border: 1px solid #d6e3f8;
            border-radius: 10px;
            padding: 0.55rem 0.7rem;
            font-size: 0.9rem;
        }

        .user-card input:disabled {
            background-color: #f5f7fb;
            color: #9aa9bf;
        }

        .user-card-actions {
            display: flex;
            gap: 0.6rem;
        }

        #usernameConfirmBtnDesktop {
            flex: 1;
            justify-content: center;
        }

        .user-card button {
            border: none;
            border-radius: 10px;
            padding: 0.55rem 0.8rem;
            font-size: 0.85rem;
            cursor: pointer;
            background-color: #4a90e2;
            color: #fff;
            transition: background-color 0.2s ease;
        }

        .user-card button.secondary {
            background-color: #e8f1ff;
            color: #3b6fb6;
        }

        .voice-clone-card button.primary,
        .modal-body button.primary {
            background-color: #4a90e2;
            color: #fff;
            border: none;
            border-radius: 999px;
            padding: 0.6rem 1.4rem;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .user-card button:disabled {
            background-color: #cbd9f0;
            cursor: not-allowed;
        }

        .lock-status {
            font-size: 0.82rem;
            color: #d9534f;
        }

        .username-hint {
            white-space: normal;
            overflow: visible;
        }

        /* å°ç›ˆå½¢è±¡å¡ç‰‡ - ä¼˜åŒ–æ¸å˜å’Œé˜´å½± */
        .ai-card {
            background: linear-gradient(135deg, #e8f4ff, #d0e1ff);
            border-radius: 20px;
            padding: 1.5rem;
            text-align: center;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.12);
            border: 1px solid rgba(255,255,255,0.8);
        }

        .ai-card-avatar {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background-color: #fff;
            margin: 0 auto 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.2rem;
            color: #4a90e2;
            border: 4px solid #4a90e2;
            box-shadow: 0 3px 10px rgba(74, 144, 226, 0.2);
        }

        .ai-name {
            font-size: 1.3rem;
            font-weight: 700;
            color: #4a90e2;
            margin-bottom: 0.6rem;
            letter-spacing: 0.5px;
        }

        .ai-desc {
            font-size: 0.9rem;
            color: #666;
            line-height: 1.5;
        }

        /* æƒ…ç»ªåˆ†ææŠ¥å‘Šæ¨¡å— - ä¼˜åŒ–å†…è¾¹è·å’Œåœ†è§’ */
        .emotion-report {
            background-color: #fff;
            border-radius: 20px;
            padding: 1.5rem;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.08);
            flex: 1;
            border: 1px solid rgba(240,247,255,0.8);
        }

        .voice-clone-card {
            background-color: #fff;
            border-radius: 20px;
            padding: 1.5rem;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.08);
            border: 1px solid rgba(240,247,255,0.8);
            margin-top: 1rem;
        }

        .voice-clone-desc {
            color: #5f6b7a;
            font-size: 0.9rem;
            margin: 0.8rem 0 1rem;
            line-height: 1.6;
        }

        .voice-clone-card .voice-clone-trigger {
            display: none;
        }

        .report-title {
            font-size: 1.15rem;
            font-weight: 700;
            color: #4a90e2;
            margin-bottom: 1.2rem;
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }

        .report-title i {
            font-size: 1.3rem;
        }

        /* æƒ…ç»ªæŒ‡æ•°è¿›åº¦æ¡ - ä¼˜åŒ–æ ·å¼ */
        .emotion-score {
            margin-bottom: 1.5rem;
        }

        .score-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 0.6rem;
        }

        .score-bar {
            width: 100%;
            height: 10px;
            background-color: #f0f5ff;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
        }

        .score-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff8a8a, #4a90e2);
            border-radius: 5px;
            width: 60%;
            transition: width 0.8s ease-in-out;
            box-shadow: 0 0 5px rgba(74, 144, 226, 0.3);
        }

        /* æƒ…ç»ªæ ‡ç­¾ - ä¼˜åŒ–åœ†è§’å’Œé…è‰² */
        .emotion-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem;
            margin-bottom: 1.5rem;
        }

        .emotion-tag {
            padding: 0.4rem 1rem;
            background-color: #e8f4ff;
            color: #4a90e2;
            border-radius: 24px;
            font-size: 0.85rem;
            border: 1px solid #d0e1ff;
        }

        /* åˆ†æå’Œå»ºè®® - ä¼˜åŒ–è¡Œé«˜ */
        .emotion-analysis, .emotion-suggest {
            margin-bottom: 1.2rem;
            font-size: 0.95rem;
            line-height: 1.6;
        }

        .analysis-label, .suggest-label {
            font-weight: 700;
            color: #4a90e2;
            margin-bottom: 0.4rem;
            display: block;
        }

        /* ç©ºçŠ¶æ€æç¤º - ä¼˜åŒ–æ ·å¼ */
        .empty-tip {
            text-align: center;
            color: #999;
            font-size: 1rem;
            padding: 4rem 0;
            line-height: 1.8;
        }

        .empty-tip i {
            font-size: 2.5rem;
            margin-bottom: 0.8rem;
            display: block;
            color: #c1d9ff;
        }

        /* åº•éƒ¨ç‰ˆæƒ - å›ºå®šåº•éƒ¨ï¼Œå°å­—æ ‡æ˜ */
        #copyrightBar {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            color: #999;
            border-top: 1px solid #f0f7ff;
            z-index: 9999;
            padding: 0.6rem 1rem calc(0.6rem + env(safe-area-inset-bottom));
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* TODO: iOS é£æ ¼æ»‘å—ï¼Œç”¨äºè¯­éŸ³è¾“å‡ºå¼€å…³ */
        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.6rem 0.2rem;
            border-top: 1px dashed #e6efff;
            font-size: 0.9rem;
            color: #3b6fb6;
        }

        .ios-switch {
            position: relative;
            width: 46px;
            height: 26px;
            border-radius: 999px;
            border: none;
            background: #d8e5fb;
            cursor: pointer;
            transition: background 0.2s ease;
            padding: 0;
        }

        .ios-switch::after {
            content: "";
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            transition: transform 0.2s ease;
        }

        .ios-switch.on {
            background: #4a90e2;
        }

        .ios-switch.on::after {
            transform: translateX(20px);
        }

        .voice-stop-btn {
            border: none;
            background: #ffe6e6;
            color: #d9534f;
            border-radius: 999px;
            padding: 0.55rem 0.9rem;
            font-size: 0.85rem;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
        }

        .voice-stop-btn:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .modal-backdrop {
            position: fixed;
            top: var(--vv-top);
            left: 0;
            right: 0;
            background: rgba(15, 25, 40, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            z-index: 1100;
            height: var(--app-height);
        }

        .modal-backdrop.active {
            display: flex;
        }

        .modal-content {
            background: #fff;
            border-radius: 18px;
            width: min(520px, 92vw);
            max-height: calc(var(--app-height) * 0.8);
            box-shadow: 0 20px 40px rgba(15, 25, 40, 0.25);
            display: flex;
            flex-direction: column;
            overflow: visible;
        }

        .modal-header {
            padding: 1rem 1.2rem 0.6rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #eef3fb;
        }

        .modal-header h3 {
            font-size: 1.05rem;
            font-weight: 700;
            color: #3b6fb6;
        }

        .modal-close {
            border: none;
            background: #e8f1ff;
            color: #3b6fb6;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
        }

        .modal-body {
            padding: 1rem 1.2rem 1.4rem;
            overflow: auto;
            -webkit-overflow-scrolling: touch;
        }

        /* TODO: è¯­éŸ³å…‹éš†è¡¨å•æ ·å¼ï¼Œä¿æŒç§»åŠ¨ç«¯å¯è¯»æ€§ */
        .voice-clone-form {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .voice-emotion-card {
            margin-top: 1rem;
            padding: 0.9rem 1rem;
            border: 1px solid #e4edf9;
            border-radius: 12px;
            background: #f9fbff;
        }

        .voice-emotion-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.8rem;
        }

        .voice-emotion-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #3b6fb6;
        }

        .voice-emotion-reset {
            border: none;
            background: #e8f1ff;
            color: #3b6fb6;
            border-radius: 999px;
            font-size: 0.8rem;
            padding: 0.3rem 0.7rem;
            cursor: pointer;
        }

        .voice-emotion-sliders {
            display: grid;
            gap: 0.7rem;
        }

        .voice-emotion-item {
            display: grid;
            grid-template-columns: 3.5rem 1fr 2.5rem;
            align-items: center;
            gap: 0.6rem;
            font-size: 0.85rem;
            color: #4b5c72;
        }

        .voice-emotion-item input[type="range"] {
            width: 100%;
        }

        .voice-emotion-value {
            text-align: right;
            font-variant-numeric: tabular-nums;
            color: #3b6fb6;
        }

        .voice-clone-form label {
            font-size: 0.85rem;
            color: #6b7c93;
        }

        .voice-clone-form input,
        .voice-clone-form textarea {
            border: 1px solid #d6e3f8;
            border-radius: 10px;
            padding: 0.55rem 0.7rem;
            font-size: 0.9rem;
        }

        .voice-clone-status {
            min-height: 1.2rem;
            font-size: 0.85rem;
            color: #6b7c93;
        }

        .voice-clone-status.success {
            color: #2f8d46;
        }

        .voice-clone-status.error {
            color: #d9534f;
        }

        .user-modal-profile {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.2rem;
        }

        .user-modal-profile .lock-status {
            margin-top: 0.2rem;
        }

        .username-actions {
            margin-top: 16px;
            display: flex;
            justify-content: flex-end;
        }

        #usernameConfirmBtn {
            position: static;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            visibility: visible;
            flex: 0 0 auto;
        }

        .username-secondary-actions {
            margin-top: 10px;
            display: flex;
            justify-content: flex-end;
        }

        .btn-primary,
        .btn-ghost {
            flex: 1;
            border-radius: 12px;
            padding: 10px 12px;
            border: 1px solid rgba(99, 102, 241, 0.2);
            font-size: 14px;
            cursor: pointer;
        }

        .btn-primary {
            color: #fff;
            background: linear-gradient(135deg, #6366f1, #4a90e2);
            border-color: rgba(99, 102, 241, 0.45);
        }

        .btn-ghost {
            color: #475569;
            background: rgba(255, 255, 255, 0.75);
        }

        .emotion-modal-content {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        body.modal-open {
            position: fixed;
            left: 0;
            right: 0;
            overflow: hidden;
        }

        body.is-mobile.modal-open {
            transform: none;
            filter: none;
        }

        /* ç§»åŠ¨ç«¯èœå•æŠ½å±‰ */
        .drawer-header {
            display: none;
            align-items: center;
            gap: 0.6rem;
            padding: 1rem 1.2rem 0.5rem;
            border-bottom: 1px solid #e6efff;
        }

        .drawer-close {
            border: none;
            background: transparent;
            font-size: 1.1rem;
            color: #4a90e2;
            cursor: pointer;
        }

        .drawer-title {
            font-weight: 600;
            color: #2f4b7c;
        }

        .mobile-toast {
            position: fixed;
            left: 50%;
            bottom: calc(20px + env(safe-area-inset-bottom));
            transform: translateX(-50%);
            background: rgba(28, 37, 59, 0.92);
            color: #fff;
            padding: 0.6rem 1rem;
            border-radius: 999px;
            font-size: 0.9rem;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1200;
        }

        .mobile-toast.show {
            opacity: 1;
        }

        /* å“åº”å¼é€‚é… - å…¨å°ºå¯¸å…¼å®¹ */
        @media (max-width: 768px) {
            input,
            textarea,
            select {
                font-size: 16px !important;
            }

            .main-container {
                flex-direction: column;
                margin: 0.8rem auto;
                gap: 1rem;
            }

            .sidebar {
                width: 100%;
                min-width: unset;
            }

            .chat-window {
                padding: 1rem 1.2rem;
            }

            .msg-container {
                max-width: 85%;
                gap: 0.6rem;
            }

            .msg-avatar {
                width: 32px;
                height: 32px;
                font-size: 1rem;
            }

            .message {
                padding: 0.8rem 1.2rem;
                font-size: 0.9rem;
            }

            .header h1 {
                font-size: 1.4rem;
            }

            .ai-card-avatar {
                width: 80px;
                height: 80px;
                font-size: 2rem;
            }

            #copyrightBar {
                font-size: 0.8rem;
                padding: 0 1rem;
                text-align: center;
            }
        }

        @media (max-width: 1023px) {
            .composer {
                flex-wrap: wrap;
            }

            .composer .voice-clone-trigger {
                display: none;
            }

            .voice-clone-card .voice-clone-trigger {
                display: inline-flex;
                width: 100%;
                justify-content: center;
            }
        }

        @media (max-width: 480px) {
            .msg-container {
                max-width: 90%;
            }

            .input-area {
                padding: 0.8rem 1.2rem;
            }

            .send-btn {
                width: 36px;
                height: 36px;
            }
        }

        body.is-mobile .header-content {
            justify-content: space-between;
        }

        body.is-mobile .header-text {
            text-align: left;
        }

        body.is-mobile .header-actions {
            display: flex;
        }

        body.is-mobile .sidebar {
            display: block;
            position: fixed;
            top: 0;
            right: 0;
            height: 100vh;
            width: min(80vw, 320px);
            max-width: 320px;
            background: #fff;
            padding: 1.2rem;
            overflow-y: auto;
            box-shadow: -12px 0 30px rgba(15, 25, 40, 0.15);
            transform: translateX(100%);
            transition: transform 0.25s ease;
            z-index: 1050;
            padding-bottom: calc(1.2rem + env(safe-area-inset-bottom));
        }

        body.is-mobile.drawer-open .sidebar {
            transform: translateX(0);
        }

        body.is-mobile .drawer-header {
            display: flex;
        }

        body.is-mobile .info-tip:hover .tooltip {
            opacity: 0;
            pointer-events: none;
        }

        body.is-mobile .info-tip .tooltip {
            left: 50%;
            right: auto;
            top: 1.8rem;
            transform: translate(-50%, -6px);
        }

        body.is-mobile .info-tip.tooltip-open .tooltip {
            transform: translate(-50%, 0);
        }

        .desktop-only { display: flex; }
        .mobile-only { display: none; }
        .tooltip,
        .hint,
        .info,
        .username-hint,
        .lock-status {
            pointer-events: none;
        }

        @media (max-width: 767px) {
            .desktop-only { display: none !important; }
            .mobile-only { display: block !important; }
            .drawer {
                position: fixed;
                top: 0;
                right: 0;
                width: 320px;
                max-width: 86vw;
                height: 100vh;
                background: #fff;
                box-shadow: -8px 0 24px rgba(0,0,0,0.08);
                transform: translateX(100%);
                transition: transform 0.3s ease;
                z-index: 100;
                overflow-y: auto;
            }
            .drawer.open { transform: translateX(0); }
            .drawer-mask {
                position: fixed;
                inset: 0;
                background: rgba(0,0,0,0.25);
                z-index: 90;
                display: none;
            }
            .drawer-mask.show { display: block !important; }
        }

    </style>
    <!-- å¼•å…¥å­—ä½“å›¾æ ‡ -->
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <!-- TODO: å›ºå®šå¸ƒå±€å®¹å™¨ï¼Œé¿å… iOS é”®ç›˜å¼¹å‡ºæ—¶ footer æŠ–åŠ¨ -->
    <div id="appShell">
        <!-- é¡¶éƒ¨å¯¼èˆªæ  - ç§»é™¤AIæ ‘æ´æ–‡å­— -->
        <header class="header topbar">
            <div class="header-content">
                <div class="header-text">
                    <h1>å¿ƒçµé¿é£æ¸¯</h1>
                    <p>å°ç›ˆé™ªä½ å€¾è¯‰æ‰€æœ‰å¿ƒäº‹ï¼Œåšä½ æœ€æ¸©æš–çš„å€¾å¬è€…</p>
                </div>
                <div id="desktopUserPanel" class="desktop-only" style="margin-left:auto;align-items:center;gap:8px;">
                <span id="header-username" style="font-size:14px;">æœªç™»å½•</span>
                <button id="header-settings-btn" class="header-action-btn" type="button">è®¾ç½®</button>
            </div>
            <div class="header-actions mobile-only">
                    <button class="header-action-btn" id="menuBtn" type="button" aria-label="æ‰“å¼€èœå•">
                        <i class="fas fa-bars"></i>
                        èœå•
                    </button>
                </div>
            </div>
        </header>

        <div id="mainScroll" class="scroll-area">
        <!-- ä¸»å®¹å™¨ - èŠå¤©æ¡†å ä¸»ä½“ -->
        <main class="main-container">
            <!-- èŠå¤©åŒºåŸŸ - ä¸»ä½“å æ¯” -->
            <section class="chat-section">
                <!-- èŠå¤©çª—å£ - æ˜¾ç¤ºåŒæ–¹å¤´åƒ -->
                <div class="chat-window" id="chat-window">
                    <div class="empty-tip" id="empty-tip">
                        <i class="fas fa-comments"></i>
                        ä½ å¥½å‘€ï½æˆ‘æ˜¯å°ç›ˆ ğŸ˜Š<br>
                        æœ‰ä»€ä¹ˆå¿ƒäº‹æƒ³å’Œæˆ‘è¯´å—ï¼Ÿæˆ‘ä¼šè®¤çœŸå€¾å¬çš„
                    </div>
                </div>

                <!-- è¾“å…¥æ¡†åŒºåŸŸ -->
                <div class="composer">
                    <div class="input-area">
                        <textarea id="msg-input" placeholder="è¾“å…¥æƒ³å€¾è¯‰çš„å†…å®¹ï¼ŒæŒ‰å›è½¦å‘é€..." rows="1"></textarea>
                        <button class="send-btn" id="send-btn" disabled>
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                    <button class="voice-clone-trigger primary" type="button" data-voice-clone-trigger>
                        <i class="fas fa-microphone"></i>
                        è¯­éŸ³å…‹éš†
                    </button>
                    <button class="voice-stop-btn" id="voice-stop-btn" type="button" disabled>
                        <i class="fas fa-volume-mute"></i>
                        åœæ­¢æ’­æŠ¥
                    </button>
                </div>
            </section>

            <!-- ä¾§è¾¹æ ï¼šç”¨æˆ·å¡ç‰‡ + å°ç›ˆå½¢è±¡ + æƒ…ç»ªåˆ†ææŠ¥å‘Šï¼ˆè¾…åŠ©å¸ƒå±€ï¼‰ -->
            <div id="drawerMask" class="drawer-mask mobile-only"></div>
        <aside id="drawer" class="sidebar drawer mobile-only">
            <div class="drawer-header">
                <button class="drawer-close" id="drawer-close-btn" type="button" aria-label="å…³é—­èœå•">
                    <i class="fas fa-arrow-left"></i>
                </button>
                <span class="drawer-title">èœå•</span>
            </div>
            <div class="user-card">
                <div class="user-card-header">
                    <div class="user-avatar-box" id="user-avatar-box">
                        <img src="/static/avatars/default.svg" alt="ç”¨æˆ·å¤´åƒ" id="user-avatar-img">
                    </div>
                    <div>
                        <div class="user-card-title" id="user-card-title">ç”¨æˆ·å</div>
                        <div class="lock-status username-hint" id="lock-status">è¾“å…¥ç”¨æˆ·ååï¼Œç‚¹å‡»ã€Œç¡®å®šã€ä¿å­˜</div>
                    </div>
                </div>

                <input type="file" id="avatar-input" accept="image/*" hidden>

                <div class="form-row">
                    <div class="label-with-tip">
                        <label for="login-username">ç”¨æˆ·å</label>
                        <button type="button" class="info-tip" aria-label="ç”¨æˆ·åè¯´æ˜">
                            <i class="fas fa-circle-info"></i>
                            <span class="tooltip">
                                ç”¨æˆ·åå°†ä½œä¸ºä½ åœ¨æ ‘æ´ä¸­çš„èº«ä»½æ ‡è¯†ï¼Œå¹¶ä¸èŠå¤©è®°å¿†ç»‘å®šã€‚<br>
                                ä¿®æ”¹ç”¨æˆ·åå°†åˆ‡æ¢åˆ°å¦ä¸€ä»½æ–°çš„å¯¹è¯è®°å¿†ã€‚
                            </span>
                        </button>
                    </div>
                    <input id="login-username" type="text" placeholder="è¯·è¾“å…¥ç”¨æˆ·å">
                </div>

                <div class="user-card-actions">
                    <button id="upload-avatar-btn" class="secondary" type="button">ä¸Šä¼ å¤´åƒ</button>
                    <button id="usernameConfirmBtnDesktop" class="btn-primary" type="button">ç¡®å®š</button>
                </div>

                <!-- TODO: Pro èœå•æ–°å¢è¯­éŸ³è¾“å‡ºå¼€å…³ -->
                <div class="setting-row">
                    <span>è¯­éŸ³è¾“å‡º</span>
                    <button class="ios-switch off" id="voice-output-toggle" type="button" role="switch" aria-checked="false"></button>
                </div>
            </div>

            <!-- æƒ…ç»ªåˆ†ææŠ¥å‘Š -->
            <div class="emotion-report">
                <h3 class="report-title">
                    <i class="fas fa-chart-line"></i>
                    æƒ…ç»ªåˆ†ææŠ¥å‘Š
                </h3>
                <div class="emotion-score">
                    <div class="score-label">
                        <span>æƒ…ç»ªæŒ‡æ•°</span>
                        <span id="emotion-score-num">60</span>/100
                    </div>
                    <div class="score-bar">
                        <div class="score-fill" id="score-fill"></div>
                    </div>
                </div>
                <div class="emotion-tags" id="emotion-tags">
                    <span class="emotion-tag">å¹³é™</span>
                    <span class="emotion-tag">æœŸå¾…</span>
                </div>
                <div class="emotion-analysis">
                    <span class="analysis-label">æƒ…ç»ªåˆ†æï¼š</span>
                    <span id="emotion-analysis">å½“å‰æœªæ£€æµ‹åˆ°æ˜æ˜¾çš„è´Ÿé¢æƒ…ç»ªï¼Œå¿ƒæ€å¤„äºå¹³å’Œçš„çŠ¶æ€ï¼Œå¯¹äº¤æµæŠ±æœ‰è½»å¾®æœŸå¾…ã€‚</span>
                </div>
                <div class="emotion-suggest">
                    <span class="suggest-label">æš–å¿ƒå»ºè®®ï¼š</span>
                    <span id="emotion-suggest">ä¿æŒè¿™ä»½å¹³å’Œçš„å¿ƒæƒ…ï¼Œå¤§èƒ†è¯´å‡ºä½ çš„æƒ³æ³•å§ï¼Œæˆ‘ä¼šä¸€ç›´åœ¨è¿™é‡Œé™ªç€ä½ ï½</span>
                </div>
            </div>

            <div class="voice-clone-card">
                <h3 class="report-title">
                    <i class="fas fa-microphone"></i>
                    è¯­éŸ³å…‹éš†
                </h3>
                <p class="voice-clone-desc">
                    TODOï¼šç§»åŠ¨ç«¯å…¥å£ä¿ç•™æ­¤æŒ‰é’®ï¼Œæ¡Œé¢ç«¯è¯·ä½¿ç”¨åº•éƒ¨è¾“å…¥åŒºçš„å¿«æ·å…¥å£ã€‚
                </p>
                <button class="voice-clone-trigger primary" type="button" data-voice-clone-trigger>
                    è¯­éŸ³å…‹éš†
                </button>
            </div>
            </aside>
        </main>
        </div>
    </div>

    <!-- åº•éƒ¨ç‰ˆæƒ - å›ºå®šåº•éƒ¨ï¼Œå°å­—æ ‡æ˜ -->
    <footer class="copyright" id="copyrightBar">
        ç‰ˆæƒæ‰€æœ‰-JSHTæ·æ€æ…§å›¾ç§‘æŠ€ ç¿»ç‰ˆå¿…ç©¶
    </footer>

    <div class="modal-backdrop" id="user-modal" aria-hidden="true">
        <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="user-modal-title">
            <div class="modal-header">
                <h3 id="user-modal-title">ç”¨æˆ·èº«ä»½</h3>
                <button class="modal-close" type="button" data-modal-close>
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="user-modal-profile">
                    <div class="user-avatar-box" id="mobile-avatar-box">
                        <img src="/static/avatars/default.svg" alt="ç”¨æˆ·å¤´åƒ" id="mobile-avatar-img">
                    </div>
                    <div>
                        <div class="lock-status username-hint" id="mobile-lock-status">è¾“å…¥ç”¨æˆ·ååï¼Œç‚¹å‡»ã€Œç¡®å®šã€ä¿å­˜</div>
                    </div>
                </div>
                <div class="form-row">
                    <div class="label-with-tip">
                        <label for="mobile-username">ç”¨æˆ·å</label>
                        <button type="button" class="info-tip" aria-label="ç”¨æˆ·åè¯´æ˜">
                            <i class="fas fa-circle-info"></i>
                            <span class="tooltip">
                                ç”¨æˆ·åå°†ä½œä¸ºä½ åœ¨æ ‘æ´ä¸­çš„èº«ä»½æ ‡è¯†ï¼Œå¹¶ä¸èŠå¤©è®°å¿†ç»‘å®šã€‚<br>
                                ä¿®æ”¹ç”¨æˆ·åå°†åˆ‡æ¢åˆ°å¦ä¸€ä»½æ–°çš„å¯¹è¯è®°å¿†ã€‚
                            </span>
                        </button>
                    </div>
                    <input id="mobile-username" type="text" placeholder="è¯·è¾“å…¥ç”¨æˆ·å">
                </div>
                <div class="username-actions">
                    <button id="usernameConfirmBtn" class="btn-primary" type="button">ç¡®å®š</button>
                </div>
                <div class="username-secondary-actions">
                    <button id="usernameCancelBtn" class="btn-ghost" type="button">å–æ¶ˆ</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-backdrop" id="emotion-modal" aria-hidden="true">
        <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="emotion-modal-title">
            <div class="modal-header">
                <h3 id="emotion-modal-title">æƒ…ç»ªåˆ†ææŠ¥å‘Š</h3>
                <button class="modal-close" type="button" data-modal-close>
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="emotion-modal-content">
                    <div class="emotion-score">
                        <div class="score-label">
                            <span>æƒ…ç»ªæŒ‡æ•°</span>
                            <span><span id="emotion-score-num-mobile">60</span>/100</span>
                        </div>
                        <div class="score-bar">
                            <div class="score-fill" id="score-fill-mobile"></div>
                        </div>
                    </div>
                    <div class="emotion-tags" id="emotion-tags-mobile">
                        <span class="emotion-tag">å¹³é™</span>
                        <span class="emotion-tag">æœŸå¾…</span>
                    </div>
                    <div class="emotion-analysis">
                        <span class="analysis-label">æƒ…ç»ªåˆ†æï¼š</span>
                        <span id="emotion-analysis-mobile">å½“å‰æœªæ£€æµ‹åˆ°æ˜æ˜¾çš„è´Ÿé¢æƒ…ç»ªï¼Œå¿ƒæ€å¤„äºå¹³å’Œçš„çŠ¶æ€ï¼Œå¯¹äº¤æµæŠ±æœ‰è½»å¾®æœŸå¾…ã€‚</span>
                    </div>
                    <div class="emotion-suggest">
                        <span class="suggest-label">æš–å¿ƒå»ºè®®ï¼š</span>
                        <span id="emotion-suggest-mobile">ä¿æŒè¿™ä»½å¹³å’Œçš„å¿ƒæƒ…ï¼Œå¤§èƒ†è¯´å‡ºä½ çš„æƒ³æ³•å§ï¼Œæˆ‘ä¼šä¸€ç›´åœ¨è¿™é‡Œé™ªç€ä½ ï½</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal-backdrop" id="voice-clone-modal" aria-hidden="true">
        <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="voice-clone-title">
            <div class="modal-header">
                <h3 id="voice-clone-title">è¯­éŸ³å…‹éš†</h3>
                <button class="modal-close" type="button" data-modal-close>
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <!-- TODO: ä¸Šä¼ å‚è€ƒéŸ³é¢‘ï¼Œåˆ›å»ºéŸ³è‰²æ¨¡å‹ -->
                <div class="voice-clone-form">
                    <label for="voice-clone-file">å‚è€ƒéŸ³é¢‘</label>
                    <input type="file" id="voice-clone-file" accept="audio/*">

                    <label for="voice-clone-name">åç§°</label>
                    <input type="text" id="voice-clone-name" value="æˆ‘çš„å£°éŸ³" maxlength="32">

                    <label for="voice-clone-desc">æè¿°ï¼ˆå¯é€‰ï¼‰</label>
                    <textarea id="voice-clone-desc" rows="2" placeholder="å¦‚ï¼šæƒ…ç»ªå¹³ç¨³ã€æ— èƒŒæ™¯éŸ³"></textarea>

                    <div class="voice-clone-status" id="voice-clone-status" role="status" aria-live="polite"></div>
                    <button class="primary" id="voice-clone-action" type="button">ä¸Šä¼ /åˆ›å»º</button>
                </div>

                <div class="voice-emotion-card">
                    <div class="voice-emotion-header">
                        <div class="voice-emotion-title">è®¾å®šæƒ…æ„Ÿå‚æ•°</div>
                        <button class="voice-emotion-reset" id="voice-emotion-reset" type="button">é‡ç½®</button>
                    </div>
                    <div class="voice-emotion-sliders">
                        <div class="voice-emotion-item">
                            <span>å¼€å¿ƒ</span>
                            <input type="range" min="0" max="1" step="0.1" value="0" data-voice-emotion="happy">
                            <span class="voice-emotion-value" data-voice-emotion-value="happy">0</span>
                        </div>
                        <div class="voice-emotion-item">
                            <span>æ„¤æ€’</span>
                            <input type="range" min="0" max="1" step="0.1" value="0" data-voice-emotion="angry">
                            <span class="voice-emotion-value" data-voice-emotion-value="angry">0</span>
                        </div>
                        <div class="voice-emotion-item">
                            <span>æ‚²ä¼¤</span>
                            <input type="range" min="0" max="1" step="0.1" value="0" data-voice-emotion="sad">
                            <span class="voice-emotion-value" data-voice-emotion-value="sad">0</span>
                        </div>
                        <div class="voice-emotion-item">
                            <span>ææƒ§</span>
                            <input type="range" min="0" max="1" step="0.1" value="0" data-voice-emotion="afraid">
                            <span class="voice-emotion-value" data-voice-emotion-value="afraid">0</span>
                        </div>
                        <div class="voice-emotion-item">
                            <span>åŒæ¶</span>
                            <input type="range" min="0" max="1" step="0.1" value="0" data-voice-emotion="disgusted">
                            <span class="voice-emotion-value" data-voice-emotion-value="disgusted">0</span>
                        </div>
                        <div class="voice-emotion-item">
                            <span>å¿§éƒ</span>
                            <input type="range" min="0" max="1" step="0.1" value="0" data-voice-emotion="melancholic">
                            <span class="voice-emotion-value" data-voice-emotion-value="melancholic">0</span>
                        </div>
                        <div class="voice-emotion-item">
                            <span>æƒŠè®¶</span>
                            <input type="range" min="0" max="1" step="0.1" value="0" data-voice-emotion="surprised">
                            <span class="voice-emotion-value" data-voice-emotion-value="surprised">0</span>
                        </div>
                        <div class="voice-emotion-item">
                            <span>å¹³é™</span>
                            <input type="range" min="0" max="1" step="0.1" value="0" data-voice-emotion="calm">
                            <span class="voice-emotion-value" data-voice-emotion-value="calm">0</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="mobile-toast" id="mobile-toast" role="status" aria-live="polite"></div>

    <script src="/static/shared_shell.js"></script>
    <script>
        const STORAGE_USERNAME_KEY = "treehole_username";
        const STORAGE_USER_ID_KEY = "treehole_user_id";
        const STORAGE_VOICE_AUDIO_ID = "voice_audio_id"; // TODO: PRO ä¸“ç”¨è¯­éŸ³å…‹éš†ç¼“å­˜ key
        const STORAGE_VOICE_OUTPUT = "voice_output_enabled"; // TODO: PRO è¯­éŸ³è¾“å‡ºå¼€å…³
        const STORAGE_VOICE_EMOTION_EXT = "voice_emotion_ext";
        const STORAGE_LIPVOICE_TTS_EXT = "lipvoice_tts_ext";
        const APP_PLAN = "pro"; // é¡µé¢ç‰ˆæœ¬å¸¸é‡
        const DEFAULT_AVATAR_URL = "/static/avatars/default.svg";
        const CURRENT_USER_ID = getOrCreateStableUserId();
        const chatHistory = [];
        let emotionLocked = false;
        let emotionDebounceTimer = null;
        // âœ…ã€æ–°å¢ï¼šæƒ…ç»ªåˆ†æè½®æ¬¡æ§åˆ¶ã€‘
        let currentRound = 0;
        let lastEmotionRound = -1;
        const EMOTION_DEBOUNCE_MS = 450;
        const EMOTION_HISTORY_LIMIT = 24;
        let isMobile = false;
        let scrollLockY = 0;
        let voiceOutputEnabled = false;
        let ttsActive = false;
        let ttsAudio = null;
        let ttsAudioUrl = null;
        let ttsAbortControllers = new Set();
        let ttsToken = 0;
        let ttsUnlocked = false;
        let ttsUnlockHinted = false;
        const isiOS = /iP(ad|hone|od)/.test(navigator.userAgent)
            || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

        const USER_ID_SHA1_PATTERN = /^u_[0-9a-f]{40}$/i;
        const USER_ID_UUID_PATTERN = /^u_[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

        function isValidUserId(userId) {
            return typeof userId === "string" && (USER_ID_SHA1_PATTERN.test(userId) || USER_ID_UUID_PATTERN.test(userId));
        }

        function createStableUserId() {
            if (crypto?.randomUUID) {
                return `u_${crypto.randomUUID()}`;
            }
            const randomHex = `${Math.random().toString(16).slice(2)}${Date.now().toString(16)}${Math.random().toString(16).slice(2)}`.slice(0, 40);
            return `u_${randomHex}`;
        }

        function safeLocalStorageGet(key) {
            try {
                return localStorage.getItem(key);
            } catch (e) {
                // TODO: iOS Safari æ— ç—•æ¨¡å¼ä¼šæ‹’ç» localStorageï¼Œéœ€å…œåº•
                return "";
            }
        }

        function safeLocalStorageSet(key, value) {
            try {
                localStorage.setItem(key, value);
            } catch (e) {
                // TODO: iOS Safari æ— ç—•æ¨¡å¼å†™å…¥å¤±è´¥æ—¶ä¿æŒå†…å­˜æ€å³å¯
            }
        }

        function getOrCreateStableUserId() {
            const stored = safeLocalStorageGet(STORAGE_USER_ID_KEY);
            if (isValidUserId(stored)) {
                return stored;
            }
            const created = createStableUserId();
            safeLocalStorageSet(STORAGE_USER_ID_KEY, created);
            return created;
        }

        function syncViewport() {
            const viewport = window.visualViewport;
            const height = viewport ? viewport.height : window.innerHeight;
            const offsetTop = viewport ? viewport.offsetTop : 0;
            document.documentElement.style.setProperty('--app-height', `${height}px`);
            document.documentElement.style.setProperty('--vv-top', `${offsetTop}px`);
        }

        function lockBodyScroll() {
            scrollLockY = window.scrollY || window.pageYOffset || 0;
            document.body.style.position = 'fixed';
            document.body.style.top = `-${scrollLockY}px`;
            document.body.style.width = '100%';
            document.body.style.left = '0';
            document.body.style.right = '0';
            document.body.classList.add('modal-open');
        }

        function unlockBodyScroll() {
            document.body.classList.remove('modal-open');
            document.body.style.position = '';
            document.body.style.top = '';
            document.body.style.width = '';
            document.body.style.left = '';
            document.body.style.right = '';
            window.scrollTo(0, scrollLockY);
            if (isiOS) {
                requestAnimationFrame(() => {
                    document.body.style.transform = 'translateZ(0)';
                    requestAnimationFrame(() => {
                        document.body.style.transform = '';
                    });
                });
            }
        }

        function restoreIOSViewport() {
            if (!isiOS) return;
            requestAnimationFrame(() => {
                window.scrollTo(0, window.scrollY || 0);
                document.body.style.transform = 'translateZ(0)';
                requestAnimationFrame(() => {
                    document.body.style.transform = '';
                });
            });
        }

        function updateDeviceMode() {
            isMobile = window.matchMedia("(max-width: 767px)").matches;
            document.body.classList.toggle('is-mobile', isMobile);
            if (!isMobile) {
                closeAllTooltips();
                closeDrawer();
            }
        }

        let toastTimer = null;
        function showToast(message = "ç³»ç»Ÿé”™è¯¯", { duration = 2200 } = {}) {
            const toast = document.getElementById('mobile-toast');
            if (!toast) return;
            toast.innerText = message;
            toast.classList.add('show');
            if (toastTimer) {
                clearTimeout(toastTimer);
                toastTimer = null;
            }
            if (duration > 0) {
                toastTimer = setTimeout(() => {
                    toast.classList.remove('show');
                    toastTimer = null;
                }, duration);
            }
        }

        function hideToast() {
            const toast = document.getElementById('mobile-toast');
            if (!toast) return;
            toast.classList.remove('show');
            if (toastTimer) {
                clearTimeout(toastTimer);
                toastTimer = null;
            }
        }

        function showErrorModal(message) {
            // TODO: ç»Ÿä¸€é”™è¯¯æç¤ºå…¥å£ï¼ˆæš‚ç”¨ toastï¼Œé¿å…æŠŠé”™è¯¯å¡è¿›èŠå¤©è®°å½•ï¼‰
            showToast(message || "æœåŠ¡æš‚ä¸å¯ç”¨");
        }

        async function handleVoiceCloneUpload() {
            if (!voiceCloneFile || !voiceCloneAction) return;
            if (!isValidUserId(CURRENT_USER_ID) || !confirmedUsername) {
                setVoiceCloneStatus("è¯·å…ˆè¾“å…¥ç”¨æˆ·åå¹¶å®Œæˆç”¨æˆ·ç»‘å®š", "error");
                showToast("è¯·å…ˆè¾“å…¥ç”¨æˆ·åå¹¶å®Œæˆç”¨æˆ·ç»‘å®š");
                return;
            }
            const file = voiceCloneFile.files?.[0];
            if (!file) {
                setVoiceCloneStatus("è¯·å…ˆé€‰æ‹©éŸ³é¢‘æ–‡ä»¶", "error");
                showToast("è¯·å…ˆé€‰æ‹©éŸ³é¢‘æ–‡ä»¶");
                return;
            }
            const name = (voiceCloneName?.value || "").trim() || "æˆ‘çš„å£°éŸ³";
            const describe = (voiceCloneDesc?.value || "").trim();
            const formData = new FormData();
            formData.append("file", file);
            formData.append("name", name);
            formData.append("describe", describe);
            formData.append("user_id", CURRENT_USER_ID);
            formData.append("emotion_params", JSON.stringify(buildVoiceCloneEmotionParams()));

            voiceCloneAction.disabled = true;
            setVoiceCloneStatus("ä¸Šä¼ ä¸­ï¼Œè¯·ç¨å€™...");

            try {
                const data = await requestVoiceClone(formData);
                if (data?.ok && data.data?.audioId) {
                    const audioId = data.data.audioId;
                    setVoiceCloneStatus(`ä¸Šä¼ æˆåŠŸï¼šaudioId=${audioId}`, "success");
                    if (isProPlan) {
                        safeLocalStorageSet(STORAGE_VOICE_AUDIO_ID, audioId);
                    }
                    showToast("è¯­éŸ³å…‹éš†ä¸Šä¼ æˆåŠŸ");
                    return;
                }
                const errorMsg = data?.msg || "ä¸Šä¼ å¤±è´¥";
                setVoiceCloneStatus(errorMsg, "error");
                showErrorModal(errorMsg);
            } finally {
                voiceCloneAction.disabled = false;
            }
        }

        function openDrawer() {
            if (!isMobile) return;
            drawer?.classList.add('open');
            drawerMask?.classList.add('show');
            lockBodyScroll();
        }

        function closeDrawer() {
            drawer?.classList.remove('open');
            drawerMask?.classList.remove('show');
            if (!document.querySelector('.modal-backdrop.active')) {
                unlockBodyScroll();
            }
        }

        async function fetchJson(url, options = {}) {
            let res;
            try {
                res = await fetch(url, options);
            } catch (e) {
                return { ok: false, msg: "ç½‘ç»œå¼‚å¸¸ï¼Œè¯·ç¨åå†è¯•", status: 0 };
            }
            const contentType = res.headers.get("content-type") || "";
            if (!contentType.includes("application/json")) {
                const text = await res.text();
                return { ok: false, msg: "æœåŠ¡æš‚ä¸å¯ç”¨", status: res.status, raw: text, nonJson: true };
            }
            try {
                const data = await res.json();
                if (!res.ok) {
                    return { ok: false, msg: data?.msg || "æœåŠ¡æš‚ä¸å¯ç”¨", status: res.status, raw: data };
                }
                return data;
            } catch (e) {
                return { ok: false, msg: "æœåŠ¡æš‚ä¸å¯ç”¨", status: res.status };
            }
        }

        let currentProfile = {
            username: "",
            avatar_url: ""
        };

        function resolveTitleText() {
            const titleText = (currentProfile.username || "").trim();
            userCardTitle.innerText = titleText || "ç”¨æˆ·å";
            const headerUsername = document.getElementById("header-username");
            if (headerUsername) headerUsername.innerText = titleText || "æœªç™»å½•";
        }

        function updateAvatar(url) {
            const nextUrl = url || DEFAULT_AVATAR_URL;
            currentProfile.avatar_url = url || "";
            userAvatarImg.src = nextUrl;
            if (mobileAvatarImg) {
                mobileAvatarImg.src = nextUrl;
            }
        }

        function getUserAvatarUrl() {
            return currentProfile.avatar_url || DEFAULT_AVATAR_URL;
        }

        function updateProfileState(profile) {
            currentProfile = { ...currentProfile, ...profile };
            resolveTitleText();
        }

        function setLockStatus(message, color) {
            lockStatus.innerText = message;
            lockStatus.style.color = color;
            if (mobileLockStatus) {
                mobileLockStatus.innerText = message;
                mobileLockStatus.style.color = color;
            }
        }

        function syncUsernameInputs(value) {
            if (loginUsernameInput) {
                loginUsernameInput.value = value;
            }
            if (mobileUsernameInput) {
                mobileUsernameInput.value = value;
            }
        }

        async function safeParseEmotionResponse(res) {
            const contentType = res.headers.get("content-type") || "";
            const cloned = res.clone();
            if (!res.ok) {
                const text = await cloned.text();
                console.warn("æƒ…ç»ªåˆ†æå“åº”é 200", res.status, text);
                return null;
            }
            if (!contentType.includes("application/json")) {
                const text = await cloned.text();
                console.warn("æƒ…ç»ªåˆ†æå“åº”é JSON", text);
                return null;
            }
            try {
                return await res.json();
            } catch (e) {
                const text = await cloned.text();
                console.warn("æƒ…ç»ªåˆ†æ JSON è§£æå¤±è´¥", e, text);
                return null;
            }
        }

        async function parseErrorMessage(res) {
            const contentType = res.headers.get("content-type") || "";
            if (contentType.includes("application/json")) {
                try {
                    const data = await res.json();
                    return data?.msg || "æœåŠ¡æš‚ä¸å¯ç”¨";
                } catch (e) {
                    return "æœåŠ¡æš‚ä¸å¯ç”¨";
                }
            }
            try {
                const text = await res.text();
                if (text) {
                    return text.length > 160 ? `${text.slice(0, 160)}...` : text;
                }
            } catch (e) {
                // ignore
            }
            return "æœåŠ¡æš‚ä¸å¯ç”¨";
        }

        async function parseErrorPayload(res) {
            const contentType = res.headers.get("content-type") || "";
            if (contentType.includes("application/json")) {
                try {
                    const data = await res.json();
                    return {
                        msg: data?.msg || "æœåŠ¡æš‚ä¸å¯ç”¨",
                        detail: data?.detail
                    };
                } catch (e) {
                    return { msg: "æœåŠ¡æš‚ä¸å¯ç”¨", detail: null };
                }
            }
            try {
                const text = await res.text();
                if (text) {
                    return {
                        msg: text.length > 160 ? `${text.slice(0, 160)}...` : text,
                        detail: null
                    };
                }
            } catch (e) {
                // ignore
            }
            return { msg: "æœåŠ¡æš‚ä¸å¯ç”¨", detail: null };
        }

        function requestVoiceClone(payload) {
            // TODO: å°è£…è¯­éŸ³å…‹éš†ä¸Šä¼ è¯·æ±‚ï¼Œé¿å…é”™è¯¯å†™å…¥èŠå¤©è®°å½•
            return fetchJson("/api/voice_clone/reference/upload", {
                method: "POST",
                body: payload
            });
        }

        function setVoiceCloneStatus(message, type = "") {
            if (!voiceCloneStatus) return;
            voiceCloneStatus.textContent = message || "";
            voiceCloneStatus.className = "voice-clone-status";
            if (type) {
                voiceCloneStatus.classList.add(type);
            }
        }

        function initVoiceOutputToggle() {
            if (!voiceOutputToggle) return;
            const stored = safeLocalStorageGet(STORAGE_VOICE_OUTPUT);
            voiceOutputEnabled = stored === "1";
            voiceOutputToggle.classList.toggle('on', voiceOutputEnabled);
            voiceOutputToggle.classList.toggle('off', !voiceOutputEnabled);
            voiceOutputToggle.setAttribute('aria-checked', voiceOutputEnabled ? 'true' : 'false');
        }

        function setVoiceOutputEnabled(nextValue) {
            voiceOutputEnabled = Boolean(nextValue);
            safeLocalStorageSet(STORAGE_VOICE_OUTPUT, voiceOutputEnabled ? "1" : "0");
            if (voiceOutputToggle) {
                voiceOutputToggle.classList.toggle('on', voiceOutputEnabled);
                voiceOutputToggle.classList.toggle('off', !voiceOutputEnabled);
                voiceOutputToggle.setAttribute('aria-checked', voiceOutputEnabled ? 'true' : 'false');
            }
            if (!voiceOutputEnabled) {
                resetTtsQueue();
            }
            showToast(voiceOutputEnabled ? "è¯­éŸ³è¾“å‡ºå·²å¼€å¯" : "è¯­éŸ³è¾“å‡ºå·²å…³é—­");
        }

        function resetTtsQueue() {
            ttsToken += 1;
            ttsActive = false;
            if (ttsAbortControllers.size) {
                ttsAbortControllers.forEach((controller) => controller.abort());
                ttsAbortControllers.clear();
            }
            if (ttsAudio) {
                ttsAudio.pause();
                ttsAudio.removeAttribute('src');
                ttsAudio.load();
            }
            if (ttsAudioUrl) {
                URL.revokeObjectURL(ttsAudioUrl);
                ttsAudioUrl = null;
            }
            hideToast();
            if (voiceStopBtn) {
                voiceStopBtn.disabled = true;
            }
        }

        function ensureTtsAudio() {
            if (ttsAudio) return;
            ttsAudio = new Audio();
            ttsAudio.preload = "auto";
            ttsAudio.setAttribute("playsinline", "");
            ttsAudio.setAttribute("webkit-playsinline", "");
        }

        function unlockTtsForIOS() {
            if (!voiceOutputEnabled || ttsUnlocked) return;
            ensureTtsAudio();
            if (!ttsAudio) return;
            // TODO: iOS Safari éœ€è¦ç”¨æˆ·æ‰‹åŠ¿è§£é”éŸ³é¢‘æ’­æ”¾
            const silentWav = "data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=";
            ttsAudio.muted = true;
            ttsAudio.src = silentWav;
            const playPromise = ttsAudio.play();
            if (playPromise && typeof playPromise.then === "function") {
                playPromise.then(() => {
                    ttsAudio.pause();
                    ttsAudio.currentTime = 0;
                    ttsAudio.muted = false;
                    ttsUnlocked = true;
                }).catch(() => {
                    ttsAudio.muted = false;
                });
            } else {
                ttsAudio.muted = false;
                ttsUnlocked = true;
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function requestVoiceCloneTts(text, token) {
            if (!isValidUserId(CURRENT_USER_ID) || !confirmedUsername) {
                throw new Error("user_id_invalid");
            }
            const ext = buildVoiceEmotionExt();
            const extPayload = Object.keys(ext).length ? ext : {};
            console.log("[TTS] extPayload =", extPayload);
            const { speed: extSpeed, ...extWithoutSpeed } = extPayload;
            const requestPayload = {
                user_id: CURRENT_USER_ID,
                text: text,
                ext: extWithoutSpeed
            };
            if (Number.isFinite(extSpeed)) {
                requestPayload.speed = extSpeed;
            }
            const controller = new AbortController();
            ttsAbortControllers.add(controller);
            try {
                const createRes = await fetch("/api/voice_clone/tts/create", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        ...requestPayload
                    }),
                    signal: controller.signal
                });
                if (token !== ttsToken) {
                    const cancelError = new Error("tts_cancelled");
                    cancelError.name = "AbortError";
                    throw cancelError;
                }
                if (!createRes.ok) {
                    const msg = await parseErrorMessage(createRes);
                    throw new Error(msg || "è¯­éŸ³åˆæˆå¤±è´¥");
                }

                const createPayload = await createRes.json();
                if (!createPayload.ok || !createPayload.taskId) {
                    throw new Error(createPayload.msg || "è¯­éŸ³åˆæˆå¤±è´¥");
                }

                const taskId = createPayload.taskId;
                const timeoutMs = 60000;
                const start = Date.now();
                let voiceUrl = "";
                let waitMs = 400;
                while (Date.now() - start < timeoutMs) {
                    if (token !== ttsToken) {
                        const cancelError = new Error("tts_cancelled");
                        cancelError.name = "AbortError";
                        throw cancelError;
                    }
                    const resultRes = await fetch(`/api/voice_clone/tts/result?user_id=${encodeURIComponent(currentUserId)}&taskId=${encodeURIComponent(taskId)}`, {
                        method: "GET",
                        signal: controller.signal
                    });
                    if (!resultRes.ok) {
                        const msg = await parseErrorMessage(resultRes);
                        throw new Error(msg || "è¯­éŸ³åˆæˆå¤±è´¥");
                    }
                    const resultPayload = await resultRes.json();
                    if (!resultPayload.ok) {
                        throw new Error(resultPayload.msg || "è¯­éŸ³åˆæˆå¤±è´¥");
                    }
                    const status = resultPayload.status;
                    if (status === 1) {
                        // å…ˆå¿«åæ…¢çš„è½®è¯¢ï¼Œå‡å°‘é¦–åŒ…ç­‰å¾…ã€‚
                        await sleep(waitMs);
                        waitMs = Math.min(waitMs + 200, 1000);
                        continue;
                    }
                    if (status === 2 && resultPayload.voiceUrl) {
                        voiceUrl = resultPayload.voiceUrl;
                        break;
                    }
                    if (status === 3) {
                        throw new Error("è¯­éŸ³åˆæˆå¤±è´¥");
                    }
                }

                if (!voiceUrl) {
                    throw new Error("ç”Ÿæˆè¾ƒæ…¢ï¼Œå¯ç¨åé‡è¯•");
                }

                const audioRes = await fetch(`/api/voice_clone/tts/audio?voiceUrl=${encodeURIComponent(voiceUrl)}`, {
                    method: "GET",
                    signal: controller.signal
                });
                if (!audioRes.ok) {
                    const msg = await parseErrorMessage(audioRes);
                    throw new Error(msg || "è¯­éŸ³åˆæˆå¤±è´¥");
                }
                const contentType = audioRes.headers.get("content-type") || "";
                if (!contentType.startsWith("audio/") && contentType !== "application/octet-stream") {
                    const { msg, detail } = await parseErrorPayload(audioRes);
                    showToast(msg || "è¯­éŸ³åˆæˆå¤±è´¥");
                    if (detail) {
                        console.warn("è¯­éŸ³åˆæˆè¿”å›ééŸ³é¢‘", detail);
                    } else {
                        console.warn("è¯­éŸ³åˆæˆè¿”å›ééŸ³é¢‘");
                    }
                    const err = new Error(msg || "è¯­éŸ³åˆæˆå¤±è´¥");
                    err.name = "TtsNonAudioError";
                    throw err;
                }
                return audioRes;
            } finally {
                ttsAbortControllers.delete(controller);
            }
        }

        function createDefaultEmotionState() {
            return {
                happy: 0,
                angry: 0,
                sad: 0,
                afraid: 0,
                disgusted: 0,
                melancholic: 0,
                surprised: 0,
                calm: 0
            };
        }

        let voiceEmotionState = createDefaultEmotionState();

        function clampEmotionValue(value) {
            if (!Number.isFinite(value)) return 0;
            return Math.min(1, Math.max(0, Math.round(value * 10) / 10));
        }

        function syncEmotionValueDisplay(key, value) {
            const display = document.querySelector(`[data-voice-emotion-value="${key}"]`);
            if (display) {
                display.innerText = value.toFixed(1).replace(/\.0$/, "");
            }
        }

        function applyEmotionState(nextState) {
            voiceEmotionState = { ...createDefaultEmotionState(), ...nextState };
            document.querySelectorAll('[data-voice-emotion]').forEach((input) => {
                const key = input.dataset.voiceEmotion;
                const value = clampEmotionValue(Number(voiceEmotionState[key] ?? 0));
                voiceEmotionState[key] = value;
                input.value = value;
                syncEmotionValueDisplay(key, value);
            });
        }

        function saveEmotionState() {
            if (!isProPlan) return;
            safeLocalStorageSet(STORAGE_VOICE_EMOTION_EXT, JSON.stringify(voiceEmotionState));
        }

        function loadVoiceEmotionState() {
            if (!isProPlan) return null;
            const raw = safeLocalStorageGet(STORAGE_VOICE_EMOTION_EXT);
            if (!raw) {
                return null;
            }
            try {
                const parsed = JSON.parse(raw);
                if (parsed && typeof parsed === "object") {
                    if (parsed.surprise !== undefined && parsed.surprised === undefined) {
                        parsed.surprised = parsed.surprise;
                        delete parsed.surprise;
                    }
                    return parsed;
                }
            } catch (err) {
                // ignore parse error
            }
            return null;
        }

        function loadEmotionState() {
            if (!isProPlan) return;
            const storedState = loadVoiceEmotionState();
            if (!storedState) {
                applyEmotionState(createDefaultEmotionState());
                return;
            }
            applyEmotionState(storedState);
        }

        function buildVoiceCloneEmotionParams() {
            const params = {};
            const baseState = createDefaultEmotionState();
            Object.keys(baseState).forEach((key) => {
                params[key] = clampEmotionValue(Number(voiceEmotionState[key] ?? 0));
            });
            return params;
        }

        function buildVoiceEmotionExt() {
            const emotionKeys = [
                "happy",
                "angry",
                "sad",
                "afraid",
                "disgusted",
                "melancholic",
                "surprised",
                "calm"
            ];
            let sourceState = voiceEmotionState;
            if (window.currentTtsExt && typeof window.currentTtsExt === "object") {
                sourceState = window.currentTtsExt;
            }
            if (!sourceState || typeof sourceState !== "object" || !Object.keys(sourceState).length) {
                const storedState = loadVoiceEmotionState();
                if (storedState) {
                    sourceState = storedState;
                }
            }
            if (sourceState?.surprise !== undefined && sourceState?.surprised === undefined) {
                sourceState = { ...sourceState, surprised: sourceState.surprise };
                delete sourceState.surprise;
            }
            const ext = {};
            const base = sourceState || {};
            const speedValue = Number(base.speed);
            const pitchValue = Number(base.pitch);
            const volumeValue = Number(base.volume);
            if (Number.isFinite(speedValue) && Math.abs(speedValue - 1) > 0.001) {
                ext.speed = speedValue;
            }
            if (Number.isFinite(pitchValue) && Math.abs(pitchValue - 1) > 0.001) {
                ext.pitch = pitchValue;
            }
            if (Number.isFinite(volumeValue) && Math.abs(volumeValue - 1) > 0.001) {
                ext.volume = volumeValue;
            }
            emotionKeys.forEach((key) => {
                const numericValue = Number(base[key]);
                if (!Number.isFinite(numericValue)) {
                    return;
                }
                const clamped = Math.min(1, Math.max(0, numericValue));
                if (clamped > 0) {
                    ext[key] = clamped;
                }
            });
            return ext;
        }
        function buildEmotionHistory(roundId, currentInput) {
            const filtered = chatHistory.filter((item) => {
                if (!item || typeof item !== "object") return false;
                if (item.round_id == null) return true;
                return item.round_id < roundId;
            });
            if (filtered.length && filtered[filtered.length - 1]?.role === "user"
                && filtered[filtered.length - 1]?.content === currentInput) {
                filtered.pop();
            }
            if (filtered.length > EMOTION_HISTORY_LIMIT) {
                return filtered.slice(-EMOTION_HISTORY_LIMIT);
            }
            return filtered;
        }

        function scheduleEmotionUpdate(content) {
            if (emotionDebounceTimer) {
                clearTimeout(emotionDebounceTimer);
            }
            emotionDebounceTimer = setTimeout(() => {
                updateEmotionOnce(content);
            }, EMOTION_DEBOUNCE_MS);
        }

        async function updateEmotionOnce(content) {
            // âœ… åŒä¸€è½®å¯¹è¯åªå…è®¸åˆ†æä¸€æ¬¡
            if (emotionLocked || lastEmotionRound === currentRound) return;
            if (!CURRENT_USER_ID || !confirmedUsername) return;
            if (!isValidUserId(CURRENT_USER_ID)) return;

            emotionLocked = true;
            lastEmotionRound = currentRound;

            const history = buildEmotionHistory(currentRound, content);

            try {
                const res = await fetch("/api/emotion", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        user_id: CURRENT_USER_ID,
                        history,
                        current_input: content,
                        round_id: currentRound
                    })

                });

                const payload = await safeParseEmotionResponse(res);
                if (!payload || !payload.ok || !payload.data) {
                    emotionAnalysis.innerText = "æƒ…ç»ªåˆ†ææš‚ä¸å¯ç”¨";
                    emotionSuggest.innerText = "å½“å‰æƒ…ç»ªåˆ†ææœåŠ¡ä¸å¯ç”¨ï¼Œç¨åå†è¯•ã€‚";
                    if (emotionAnalysisMobile && emotionSuggestMobile) {
                        emotionAnalysisMobile.innerText = "æƒ…ç»ªåˆ†ææš‚ä¸å¯ç”¨";
                        emotionSuggestMobile.innerText = "å½“å‰æƒ…ç»ªåˆ†ææœåŠ¡ä¸å¯ç”¨ï¼Œç¨åå†è¯•ã€‚";
                    }
                    return;
                }
                const data = payload.data;
                updateEmotionUI(data);

            } catch (e) {
                console.error("æƒ…ç»ªåˆ†æå¤±è´¥", e);
            } finally {
                emotionLocked = false;
            }
        }

        function updateEmotionUI(data) {
            if (!data) return;
            emotionScoreNum.innerText = data.score;
            scoreFill.style.width = data.score + "%";
            if (emotionScoreNumMobile && scoreFillMobile) {
                emotionScoreNumMobile.innerText = data.score;
                scoreFillMobile.style.width = data.score + "%";
            }

            emotionTags.innerHTML = "";
            if (emotionTagsMobile) {
                emotionTagsMobile.innerHTML = "";
            }
            if (Array.isArray(data.tags)) {
                data.tags.forEach(tag => {
                    const span = document.createElement("span");
                    span.className = "emotion-tag";
                    span.innerText = tag;
                    emotionTags.appendChild(span);
                    if (emotionTagsMobile) {
                        const mobileSpan = document.createElement("span");
                        mobileSpan.className = "emotion-tag";
                        mobileSpan.innerText = tag;
                        emotionTagsMobile.appendChild(mobileSpan);
                    }
                });
            }

            emotionAnalysis.innerText = data.analysis;
            emotionSuggest.innerText = data.suggestion;
            if (emotionAnalysisMobile && emotionSuggestMobile) {
                emotionAnalysisMobile.innerText = data.analysis;
                emotionSuggestMobile.innerText = data.suggestion;
            }
        }

        // è·å–DOMå…ƒç´ 
        const chatWindow = document.getElementById('chat-window');
        const msgInput = document.getElementById('msg-input');
        const sendBtn = document.getElementById('send-btn');
        const emptyTip = document.getElementById('empty-tip');
        const emotionScoreNum = document.getElementById('emotion-score-num');
        const scoreFill = document.getElementById('score-fill');
        const emotionTags = document.getElementById('emotion-tags');
        const emotionAnalysis = document.getElementById('emotion-analysis');
        const emotionSuggest = document.getElementById('emotion-suggest');
        const loginUsernameInput = document.getElementById('login-username');
        const uploadAvatarBtn = document.getElementById('upload-avatar-btn');
        const avatarInput = document.getElementById('avatar-input');
        const userAvatarBox = document.getElementById('user-avatar-box');
        const userAvatarImg = document.getElementById('user-avatar-img');
        const lockStatus = document.getElementById('lock-status');
        const userCardTitle = document.getElementById('user-card-title');
        const mobileMenuBtn = document.getElementById('menuBtn');
        const drawerCloseBtn = document.getElementById('drawer-close-btn');
        const drawer = document.getElementById('drawer');
        const drawerMask = document.getElementById('drawerMask');
        const userModal = document.getElementById('user-modal');
        const emotionModal = document.getElementById('emotion-modal');
        const headerSettingsBtn = document.getElementById('header-settings-btn');
        const mobileAvatarBox = document.getElementById('mobile-avatar-box');
        const mobileAvatarImg = document.getElementById('mobile-avatar-img');
        const mobileUsernameInput = document.getElementById('mobile-username');
        const mobileLockStatus = document.getElementById('mobile-lock-status');
        const usernameConfirmBtn = document.getElementById('usernameConfirmBtn');
        const usernameCancelBtn = document.getElementById('usernameCancelBtn');
        const emotionScoreNumMobile = document.getElementById('emotion-score-num-mobile');
        const scoreFillMobile = document.getElementById('score-fill-mobile');
        const emotionTagsMobile = document.getElementById('emotion-tags-mobile');
        const emotionAnalysisMobile = document.getElementById('emotion-analysis-mobile');
        const emotionSuggestMobile = document.getElementById('emotion-suggest-mobile');
        const voiceCloneTriggers = document.querySelectorAll('[data-voice-clone-trigger]');
        const voiceCloneModal = document.getElementById('voice-clone-modal');
        const voiceCloneAction = document.getElementById('voice-clone-action');
        const voiceCloneFile = document.getElementById('voice-clone-file');
        const voiceCloneName = document.getElementById('voice-clone-name');
        const voiceCloneDesc = document.getElementById('voice-clone-desc');
        const voiceCloneStatus = document.getElementById('voice-clone-status');
        const voiceEmotionReset = document.getElementById('voice-emotion-reset');
        const voiceOutputToggle = document.getElementById('voice-output-toggle');
        const voiceStopBtn = document.getElementById('voice-stop-btn');
                const isProPlan = APP_PLAN === "pro";


        const settingsBtn = document.getElementById("settingsBtn");
        if (settingsBtn) {
            const allow = location.pathname === "/" || location.pathname === "/index.html";
            if (!allow) settingsBtn.remove();
        }

        function clearChatWindow() {
            chatWindow.innerHTML = "";
            emptyTip.style.display = 'block';
        }

        function renderHistory(history) {
            clearChatWindow();
            if (!Array.isArray(history) || history.length === 0) {
                return;
            }
            emptyTip.style.display = 'none';
            history.forEach((item) => {
                if (!item || !item.role || !item.content) return;
                addMessage(item.content, item.role === "user" ? "user" : "ai");
            });
        }

        async function loadHistory() {
            if (!isValidUserId(CURRENT_USER_ID) || !confirmedUsername) return;
            const data = await fetchJson(`/load_history?user_id=${encodeURIComponent(CURRENT_USER_ID)}`);
            if (!data || !data.ok) {
                showErrorModal(data?.msg || "åŠ è½½å†å²å¤±è´¥");
                return;
            }
            chatHistory.length = 0;
            data.history.forEach((item) => chatHistory.push(item));
            renderHistory(data.history);
        }

        async function loadProfile() {
            if (!isValidUserId(CURRENT_USER_ID)) return false;
            const data = await fetchJson(`/profile?user_id=${encodeURIComponent(CURRENT_USER_ID)}`);
            if (!data || !data.ok) {
                showErrorModal(data?.msg || "èµ„æ–™åŠ è½½å¤±è´¥");
                return false;
            }
            const profileData = data.profile || {};
            const nextUsername = (profileData.username || "").trim();
            if (nextUsername) {
                confirmedUsername = nextUsername;
                pendingUsername = nextUsername;
                safeLocalStorageSet(STORAGE_USERNAME_KEY, confirmedUsername);
                syncUsernameInputs(nextUsername);
            }
            updateProfileState({
                username: nextUsername
            });
            updateAvatar(data.profile?.avatar_url);
            await loadHistory();
            return true;
        }

        let pendingUsername = "";
        let confirmedUsername = "";

        function handleUsernameInput(value) {
            pendingUsername = (value || "").trim();
            syncUsernameInputs(pendingUsername);
            setLockStatus("è¾“å…¥å®Œæˆåç‚¹å‡»ã€Œç¡®å®šã€ä¿å­˜", "#6b7280");
        }

        async function confirmUsername() {
            if (!pendingUsername) {
                return;
            }
            const res = await fetch("/api/user/profile", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ user_id: CURRENT_USER_ID, username: pendingUsername })
            });
            const data = await res.json();
            if (!res.ok || !data?.ok) {
                setLockStatus("èµ„æ–™ä¿å­˜å¤±è´¥", "#d9534f");
                return;
            }
            confirmedUsername = pendingUsername;
            safeLocalStorageSet(STORAGE_USERNAME_KEY, confirmedUsername);
            syncUsernameInputs(confirmedUsername);
            updateProfileState({ username: confirmedUsername });
            setLockStatus("èµ„æ–™å·²ä¿å­˜", "#3b6fb6");
            await loadProfile();
            closeModal(userModal);
            showToast("èµ„æ–™å·²ä¿å­˜");
            sendBtn.disabled = !isValidUserId(CURRENT_USER_ID) || !confirmedUsername || msgInput.value.trim() === "";
        }

        function bindUsernameConfirmButtons(confirmFn) {
            const ids = ["usernameConfirmBtn", "usernameConfirmBtnDesktop"];
            ids.forEach((id) => {
                const el = document.getElementById(id);
                if (el) el.addEventListener("click", confirmFn);
            });
        }

        async function persistProfile({ avatarUrl } = {}) {
            if (!CURRENT_USER_ID || !confirmedUsername) {
                setLockStatus("è¯·å…ˆä¿å­˜ç”¨æˆ·å", "#d9534f");
                return false;
            }
            const payload = { user_id: CURRENT_USER_ID };
            if (avatarUrl !== undefined) {
                payload.avatar_url = avatarUrl || "";
            }
            const data = await fetchJson("/profile", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload)
            });
            if (data?.ok) {
                setLockStatus("èµ„æ–™å·²ä¿å­˜", "#3b6fb6");
                return true;
            }
            setLockStatus("èµ„æ–™ä¿å­˜å¤±è´¥", "#d9534f");
            return false;
        }

        async function uploadAvatar(file) {
                        if (!file || !CURRENT_USER_ID || !confirmedUsername) return;
            const formData = new FormData();
            formData.append("file", file);
            formData.append("user_id", CURRENT_USER_ID);

            const data = await fetchJson("/avatar_upload", {
                method: "POST",
                body: formData
            });
            if (data?.ok) {
                updateAvatar(data.avatar_url);
                const saved = await persistProfile({ avatarUrl: data.avatar_url });
                if (saved) {
                    setLockStatus("å¤´åƒå·²æ›´æ–°", "#3b6fb6");
                }
            } else {
                setLockStatus("å¤´åƒä¸Šä¼ å¤±è´¥", "#d9534f");
            }
        }

        function openAvatarPicker() {
                        if (!CURRENT_USER_ID || !confirmedUsername) {
                setLockStatus("è¯·å…ˆä¿å­˜ç”¨æˆ·å", "#d9534f");
                return;
            }
            avatarInput.click();
        }

        if (uploadAvatarBtn) {
            uploadAvatarBtn.addEventListener('click', openAvatarPicker);
        }
        if (userAvatarBox) {
            userAvatarBox.addEventListener('click', openAvatarPicker);
        }
        if (mobileAvatarBox) {
            mobileAvatarBox.addEventListener('click', openAvatarPicker);
        }
        if (avatarInput) {
            avatarInput.addEventListener('change', (e) => {
                const file = e.target.files?.[0];
                if (file) {
                    uploadAvatar(file);
                }
                e.target.value = "";
            });
        }
        if (loginUsernameInput) {
            loginUsernameInput.addEventListener('input', () => {
                handleUsernameInput(loginUsernameInput.value);
            });
        }

        if (mobileUsernameInput) {
            mobileUsernameInput.addEventListener('input', () => {
                handleUsernameInput(mobileUsernameInput.value);
            });
            mobileUsernameInput.addEventListener('blur', restoreIOSViewport);
        }

        bindUsernameConfirmButtons(confirmUsername);
        if (usernameCancelBtn) {
            usernameCancelBtn.addEventListener('click', () => closeModal(userModal));
        }

        if (loginUsernameInput) {
            const lastUsername = safeLocalStorageGet(STORAGE_USERNAME_KEY);
            if (lastUsername) {
                pendingUsername = lastUsername;
                confirmedUsername = lastUsername;
                syncUsernameInputs(lastUsername);
                updateProfileState({ username: lastUsername });
            }
            if (confirmedUsername) {
                loadProfile();
            }
        }

        function openModal(modal) {
            if (!modal) return;
            const hasActiveModal = document.querySelector('.modal-backdrop.active');
            modal.classList.add('active');
            modal.setAttribute('aria-hidden', 'false');
            if (!hasActiveModal) {
                lockBodyScroll();
            }
        }

        function closeModal(modal) {
            if (!modal) return;
            modal.classList.remove('active');
            modal.setAttribute('aria-hidden', 'true');
            if (!document.querySelector('.modal-backdrop.active')) {
                unlockBodyScroll();
            }
        }

        function closeAllModals() {
            document.querySelectorAll('.modal-backdrop.active').forEach((modal) => {
                closeModal(modal);
            });
        }

        function closeAllTooltips() {
            document.querySelectorAll('.info-tip.tooltip-open').forEach((btn) => {
                btn.classList.remove('tooltip-open');
                const tooltip = btn.querySelector('.tooltip');
                if (tooltip) {
                    tooltip.style.left = '';
                    tooltip.style.right = '';
                    tooltip.style.transform = '';
                }
            });
        }

        function positionTooltip(button) {
            const tooltip = button.querySelector('.tooltip');
            if (!tooltip) return;
            tooltip.style.maxWidth = '90vw';
            tooltip.style.left = '';
            tooltip.style.right = '';
            tooltip.style.transform = '';
            requestAnimationFrame(() => {
                const rect = tooltip.getBoundingClientRect();
                if (rect.left < 8) {
                    tooltip.style.left = '0';
                    tooltip.style.right = 'auto';
                    tooltip.style.transform = 'translateY(0)';
                } else if (rect.right > window.innerWidth - 8) {
                    tooltip.style.left = 'auto';
                    tooltip.style.right = '0';
                    tooltip.style.transform = 'translateY(0)';
                }
            });
        }

        function setupTooltips() {
            document.querySelectorAll('.info-tip').forEach((btn) => {
                btn.addEventListener('click', (event) => {
                    if (!isMobile) return;
                    event.stopPropagation();
                    const isOpen = btn.classList.contains('tooltip-open');
                    closeAllTooltips();
                    if (!isOpen) {
                        btn.classList.add('tooltip-open');
                        positionTooltip(btn);
                    }
                });
            });

            document.addEventListener('click', () => {
                if (isMobile) {
                    closeAllTooltips();
                }
            });
        }

        if (headerSettingsBtn) {
            headerSettingsBtn.addEventListener('click', () => {
                openModal(userModal);
            });
        }

        if (mobileMenuBtn) {
            mobileMenuBtn.addEventListener('click', () => {
                if (!isMobile) return;
                openDrawer();
            });
        }

        if (isMobile && drawerCloseBtn) {
            drawerCloseBtn.addEventListener('click', () => {
                closeDrawer();
            });
        }

        if (isMobile && drawerMask) {
            drawerMask.addEventListener('click', () => {
                closeDrawer();
            });
        }

        if (voiceCloneTriggers.length) {
            voiceCloneTriggers.forEach((btn) => {
                btn.addEventListener('click', () => {
                    setVoiceCloneStatus("");
                    loadEmotionState();
                    openModal(voiceCloneModal);
                });
            });
        }

        if (voiceCloneAction) {
            voiceCloneAction.addEventListener('click', () => {
                handleVoiceCloneUpload();
            });
        }

        if (voiceOutputToggle) {
            voiceOutputToggle.addEventListener('click', () => {
                setVoiceOutputEnabled(!voiceOutputEnabled);
            });
        }

        if (voiceStopBtn) {
            voiceStopBtn.addEventListener('click', () => {
                resetTtsQueue();
                showToast("å·²åœæ­¢æ’­æŠ¥");
            });
        }

        document.querySelectorAll('[data-voice-emotion]').forEach((input) => {
            input.addEventListener('input', (event) => {
                const target = event.currentTarget;
                const key = target.dataset.voiceEmotion;
                const value = clampEmotionValue(Number(target.value));
                voiceEmotionState[key] = value;
                target.value = value;
                syncEmotionValueDisplay(key, value);
                saveEmotionState();
            });
        });

        if (voiceEmotionReset) {
            voiceEmotionReset.addEventListener('click', () => {
                applyEmotionState(createDefaultEmotionState());
                saveEmotionState();
            });
        }

        document.querySelectorAll('[data-modal-close]').forEach((btn) => {
            btn.addEventListener('click', () => {
                closeAllModals();
            });
        });

        document.querySelectorAll('.modal-backdrop').forEach((backdrop) => {
            backdrop.addEventListener('click', (event) => {
                if (event.target === backdrop) {
                    closeModal(backdrop);
                }
            });
        });

        window.addEventListener('resize', () => {
            const wasMobile = isMobile;
            updateDeviceMode();
            if (wasMobile !== isMobile) {
                closeAllTooltips();
            }
        });

        syncViewport();
        updateDeviceMode();
        if (!isMobile && drawer) {
            drawer.remove();
            drawerMask?.remove();
        }
        setupTooltips();
        initVoiceOutputToggle();

        window.addEventListener('resize', syncViewport);
        window.addEventListener('orientationchange', syncViewport);
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', syncViewport);
            window.visualViewport.addEventListener('scroll', syncViewport);
        }

        // ç›‘å¬è¾“å…¥æ¡†å˜åŒ–ï¼Œæ§åˆ¶å‘é€æŒ‰é’®çŠ¶æ€+è‡ªé€‚åº”é«˜åº¦
        msgInput.addEventListener('input', () => {
            const content = msgInput.value.trim();
            sendBtn.disabled = !isValidUserId(CURRENT_USER_ID) || !confirmedUsername || content === '';
            // è‡ªé€‚åº”è¾“å…¥æ¡†é«˜åº¦
            msgInput.style.height = 'auto';
            msgInput.style.height = Math.min(msgInput.scrollHeight, 120) + 'px';
        });

        // å›è½¦å‘é€ï¼ˆæŒ‰ä½shift+å›è½¦æ¢è¡Œï¼‰
        msgInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // ç‚¹å‡»å‘é€æŒ‰é’®
        sendBtn.addEventListener('click', sendMessage);

        async function sendMessage() {
        if (!isValidUserId(CURRENT_USER_ID) || !confirmedUsername) {
            setLockStatus("è¯·å…ˆä¿å­˜ç”¨æˆ·å", "#d9534f");
            showErrorModal("è¯·å…ˆè¾“å…¥å¹¶ç¡®è®¤ç”¨æˆ·å");
            return;
        }
        const content = msgInput.value.trim();
        if (!content) return;

        let ttsRequestToken = null;
        if (voiceOutputEnabled) {
            unlockTtsForIOS();
            resetTtsQueue();
            ttsRequestToken = ttsToken;
        }

        // âœ…ã€æ–°å¢ï¼šå¼€å¯æ–°ä¸€è½®å¯¹è¯ã€‘
        currentRound++;

        // ç”¨æˆ·æ¶ˆæ¯
        addMessage(content, 'user');
        scheduleEmotionUpdate(content);
        chatHistory.push({
            role: "user",
            content: content,
            round_id: currentRound
        });
        // ç„¶åæ›´æ–° UI
        msgInput.value = '';
        msgInput.style.height = 'auto';
        sendBtn.disabled = true;
        emptyTip.style.display = 'none';

        // åˆ›å»º AI æ¶ˆæ¯æ°”æ³¡ï¼ˆç©ºçš„ï¼Œç”¨æ¥æµï¼‰
        const aiWrap = document.createElement('div');
        aiWrap.className = 'msg-container ai-msg-wrap';

        const avatar = document.createElement('div');
        avatar.className = 'msg-avatar ai-avatar';
        avatar.innerHTML = '<i class="fas fa-girl"></i>';

        const aiMsg = document.createElement('div');
        aiMsg.className = 'message ai-msg';
        aiMsg.innerText = '';

        aiWrap.appendChild(avatar);
        aiWrap.appendChild(aiMsg);
        chatWindow.appendChild(aiWrap);
        chatWindow.scrollTop = chatWindow.scrollHeight;
        showLoading();

        try {
            const resp = await fetch("/chat_stream", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    user_id: CURRENT_USER_ID,   // â† å¿…é¡»æœ‰
                    history: chatHistory,
                    user_input: content,
                    round_id: currentRound
                })

            });
            const contentType = resp.headers.get("content-type") || "";
            if (!resp.ok || contentType.includes("application/json") || contentType.includes("text/html")) {
                const errMsg = await parseErrorMessage(resp);
                removeLoading();
                aiWrap.remove();
                showErrorModal(errMsg);
                return;
            }
            if (!resp.body) {
                removeLoading();
                aiWrap.remove();
                showErrorModal("æœåŠ¡æš‚ä¸å¯ç”¨");
                return;
            }
            removeLoading();

            const reader = resp.body.getReader();
            const decoder = new TextDecoder("utf-8");

            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                const chunkText = decoder.decode(value);
                aiMsg.innerText += chunkText;
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }
            const finalText = aiMsg.innerText.trim();
            if (voiceOutputEnabled && finalText) {
                try {
                    ttsActive = true;
                    if (voiceStopBtn) {
                        voiceStopBtn.disabled = false;
                    }
                    showToast("è¯­éŸ³ç”Ÿæˆä¸­â€¦", { duration: 0 });
                    const res = await requestVoiceCloneTts(finalText, ttsRequestToken);
                    if (ttsRequestToken !== ttsToken) return;
                    const blob = await res.blob();
                    if (ttsRequestToken !== ttsToken) return;
                    ensureTtsAudio();
                    const url = URL.createObjectURL(blob);
                    try {
                        if (ttsAudioUrl) {
                            URL.revokeObjectURL(ttsAudioUrl);
                        }
                        ttsAudioUrl = url;
                        ttsAudio.src = url;
                        let cleanup = () => {};
                        const playEnded = new Promise((resolve, reject) => {
                            const onEnd = () => {
                                cleanup();
                                resolve();
                            };
                            const onError = () => {
                                cleanup();
                                reject(new Error("audio_error"));
                            };
                            cleanup = () => {
                                ttsAudio.removeEventListener("ended", onEnd);
                                ttsAudio.removeEventListener("error", onError);
                            };
                            ttsAudio.addEventListener("ended", onEnd);
                            ttsAudio.addEventListener("error", onError);
                        });
                        const playPromise = ttsAudio.play();
                        if (playPromise && typeof playPromise.then === "function") {
                            try {
                                await playPromise;
                                hideToast();
                            } catch (playError) {
                                cleanup();
                                hideToast();
                                throw playError;
                            }
                        } else {
                            hideToast();
                        }
                        await playEnded;
                    } finally {
                        if (ttsAudioUrl === url) {
                            URL.revokeObjectURL(url);
                            ttsAudioUrl = null;
                        }
                    }
                } catch (err) {
                    const errorName = err?.name || "";
                    const errorMessage = err?.message || "è¯­éŸ³åˆæˆå¤±è´¥";
                    if (errorName === "NotAllowedError") {
                        if (!ttsUnlockHinted) {
                            ttsUnlockHinted = true;
                            showToast("è¯·å…ˆç‚¹å‡»å‘é€æŒ‰é’®ä»¥å¯ç”¨è¯­éŸ³æ’­æ”¾");
                        }
                    } else if (errorName === "AbortError") {
                        // ç”¨æˆ·åœæ­¢æˆ–åˆ‡æ¢æ—¶ä¸»åŠ¨å–æ¶ˆè¯·æ±‚
                    } else if (errorName === "TtsNonAudioError") {
                        // å·²åœ¨è¯·æ±‚é˜¶æ®µæç¤º toast
                    } else {
                        showToast(errorMessage);
                    }
                    console.warn("è¯­éŸ³åˆæˆå¤±è´¥", err);
                } finally {
                    hideToast();
                    if (ttsRequestToken === ttsToken) {
                        ttsActive = false;
                        if (voiceStopBtn) {
                            voiceStopBtn.disabled = true;
                        }
                    }
                }
            }
            chatHistory.push({
                role: "assistant",
                content: aiMsg.innerText,
                round_id: currentRound
            });
        }
            catch (err) {
                removeLoading();
                aiWrap.remove();
                showErrorModal("è¿æ¥å¤±è´¥ï¼Œè¯·ç¨åå†è¯•");
            }
        }

        // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©çª—å£ï¼ˆæ ¸å¿ƒï¼šå¸¦åŒæ–¹å¤´åƒï¼‰
        function addMessage(content, type, emotion = 'normal') {
            // åˆ›å»ºæ¶ˆæ¯å®¹å™¨ï¼ˆå¤´åƒ+æ°”æ³¡ï¼‰
            const msgContainer = document.createElement('div');
            // åˆ›å»ºå¤´åƒå…ƒç´ 
            const avatar = document.createElement('div');
            // åˆ›å»ºæ¶ˆæ¯æ°”æ³¡
            const messageDiv = document.createElement('div');

            // åŒºåˆ†ç”¨æˆ·/AIæ¶ˆæ¯çš„æ ·å¼å’Œå†…å®¹
            if (type === 'user') {
                // ç”¨æˆ·æ¶ˆæ¯ï¼šå®¹å™¨å³å¯¹é½ã€å¤´åƒè“è‰²ï¼ˆç”¨æˆ·ï¼‰ã€æ°”æ³¡è“è‰²
                msgContainer.className = 'msg-container user-msg-wrap';
                avatar.className = 'msg-avatar user-avatar';
                const img = document.createElement('img');
                img.src = getUserAvatarUrl();
                img.alt = 'ç”¨æˆ·å¤´åƒ';
                avatar.appendChild(img);
                messageDiv.className = 'message user-msg';
            } else {
                // AIæ¶ˆæ¯ï¼šå®¹å™¨å·¦å¯¹é½ã€å¤´åƒæµ…è“ï¼ˆå°ç›ˆï¼‰ã€æ°”æ³¡æµ…è“
                msgContainer.className = 'msg-container ai-msg-wrap';
                avatar.className = 'msg-avatar ai-avatar';
                avatar.innerHTML = '<i class="fas fa-girl"></i>';
                messageDiv.className = 'message ai-msg';
                messageDiv.dataset.emotion = emotion;
            }

            // ç»„è£…æ¶ˆæ¯ç»“æ„ï¼šå®¹å™¨ -> å¤´åƒ + æ°”æ³¡
            messageDiv.innerText = content;
            msgContainer.appendChild(avatar);
            msgContainer.appendChild(messageDiv);
            chatWindow.appendChild(msgContainer);

            // è‡ªåŠ¨æ»šåŠ¨åˆ°æœ€æ–°æ¶ˆæ¯
            chatWindow.scrollTop = chatWindow.scrollHeight;


        }
        // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»ï¼ˆå¸¦å°ç›ˆå¤´åƒï¼Œé€‚é…å¸ƒå±€ï¼‰
            function showLoading() {
                const loadingWrap = document.createElement('div');
                const avatar = document.createElement('div');
                const loadingDiv = document.createElement('div');

                loadingWrap.className = 'loading-wrap';
                avatar.className = 'msg-avatar ai-avatar';
                avatar.innerHTML = '<i class="fas fa-girl"></i>';
                loadingDiv.className = 'loading';
                loadingDiv.id = 'loading-animation';
                loadingDiv.innerHTML = `
                <div class="loading-dot"></div>
                <div class="loading-dot"></div>
                <div class="loading-dot"></div>
            `;

                loadingWrap.appendChild(avatar);
                loadingWrap.appendChild(loadingDiv);
                chatWindow.appendChild(loadingWrap);
                chatWindow.scrollTop = chatWindow.scrollHeight;
            }
        // ç§»é™¤åŠ è½½åŠ¨ç”»
        function removeLoading() {
            const loading = document.getElementById('loading-animation');
            if (loading) loading.parentElement.remove();
        }

    </script>
</body>
</html>
